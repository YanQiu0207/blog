## 关键点

- 每种模式是如何工作的
- 如何确定哪种模式可以用来解决给定问题

简单递归实现 --> 记忆逻辑 --> 自底向上（表格法）

时间复杂度和空间复杂度

实践思路：

- 识别这个问题可以采用动态规划解决
- 识别哪种动态编程模式适合于这个问题
- 将问题拆分为多个子问题
- 设计算法解决子问题并合并它们的解

## 动态规划介绍

### 什么时候使用 DP

最优子结构：一个小问题的解能帮我们解决更大的问题

特征：有重复或重叠的子问题

优化：存储和复用子问题的解，把时间复杂度从指数减到多项式

### 定义 DP 问题的特征

*   最优子结构：如果一个问题能够分解为小的子问题，并且这些子问题的最优解存在，并有助于给定问题的解，那意味着这个问题存在一个最优子结构
*   重叠子问题：如果问题的解需要重复解决某些子问题，该问题被称为具有重叠子问题的特征，并且可能可以使用 DP 进行优化

### 例子

最长公共子序列
唯一路径

### 什么时候不使用 DP

DP 不是一个银弹，有两类场景我们不应该使用 DP:

*   递归不直接转换为DP：不存在重复的子问题
*   贪心 vs 回溯 vs DP：考虑是否可使用贪心算法解决问题

贪心算法：把一个问题分解为多个子问题，在不考虑整体问题的情况下，独立找到各个子问题的最优解。对于某些问题，这样也能全局最优解。但对于另一些问题，有局部最优解并不是全局最优解的风险。但是，如果局部最优解已经足够好，或者在解空间穷举搜索的代价过大，这个风险也是可以接受的。

*   最小生成树：Kruskal's algorithm
*   最短路径：Dijkstra's algorithm

回溯：在整个解空间中穷举搜索以找到最优解

*   N-Queens
*   Sudoku Solver

### 实现动态规划的方法

#### 自顶向下

备忘法是对朴素递归方法的一种增强，核心是存储子问题的解以避免重复计算，底层原理是空间换时间

#### 自下而上

制表法：先解决最小的问题，存储结果，然后基于这些结果来计算大问题

相比备忘法，制表法通常是使用迭代来实现，避免了机器最大调用栈深度的限制

### 现实世界中的问题

*    资源分配：分配具有不同成本和生产率的资源，以便在指定时间内完成任务
*    填充箱子：给予无限量供应的大小和价格各不相同的网球，填充一个有限容量的箱子，但是价值要最高
*    生成一串数字
*    剽窃检测：检测两个文本的相似度以确定是否一个抄袭另一个
*    协助程序员使用括号：检测遗漏的括号和确定具有最少删除和插入操作的解决方案

### 参考

- 之前极客时间买的课，复习下时间和空间复杂度的计算方法