## 应用场景

（1）**异步解耦**：将同步消息转换为异步通知，以提高系统性能以及解耦生产者和消费者

- 将业务流程中的非核心操作从同步改为异步，降低接口延迟，提高系统性能。例如用户注册时要发送邮件和送积分，接口返回时用户数据肯定已增加成功，但邮件和积分可以通过消息队列慢慢发送。

- 生产者和消费者可以独立进行维护和扩展，而不会相互影响。例如消费者宕机或维护，生产者仍然可以继续向消息队列发送数据；增加消费者并不需要修改生产者，增加生产者也不需要修改消费者

（2）**削峰填谷**：缓冲上游生产者瞬时突发的流量，消费者可以平滑地消费流量

如果上游发送能力很强并且没有中间件保护，下游系统很可能被压垮，导致全链路雪崩

## 基本组成

kafka 的系统架构：待续

kafka 的角色：

- Producer
- Broker
- Consumer
- Zookpeer

kafka 的概念：

- topic
- partition
- segment
- offset

## 核心原理

### 可靠性

核心是保证消息不丢失并且最好只被消费一次，涉及如下环节：

- 生产者可靠地把消息发送到 Broker
- Broker 持久化消息
- 消息最好只被消费一次

（1）

（2）

#### 消息最好只被消费一次

Comsumer 从 Broker 中拉取订阅的消息并进行消费，消费过程中需要向 kafka 报告自己的位移数据。Broker 收到消息位移后才认为该消息已经被消费了。

（1）主动提交

消费过程：

- 消费者从 Kafka 主题中读取一批消息
- 消费者处理这些消息
- 在后台，Kafka 消费者客户端会定期（根据 auto.commit.interval.ms 配置的时间间隔）自动提交消费者最后读取的偏移量

存在的问题：

- **消息丢失**：如果处理消息的过程中报错，中断了业务逻辑，而偏移量被自动提交，则相关消息就丢失了
- **重复消费**：如果在处理消息之后，提交偏移量之前，消费者出现了崩溃。那么消费者恢复后，它会从最后一次提交的偏移量重新开始消费消息，可能会导致一些消息被重复消费

消息丢失其实不是问题，如果处理消息的过程中报错，根据错误信息修复数据就行

（2）手动提交

提交方式：

- 同步提交：阻塞消费者直到偏移量被成功提交，或者抛出异常（可靠）。但可能会降低消费者的吞吐量，尤其是在网络延迟或其他问题导致提交时间较长的情况下。

- 异步提交：不会阻塞当前线程，可以提高消费者的吞吐量，尤其是在处理大量消息的情况下。但需要考虑如何处理偏移量覆盖的问题（复杂性），甚至可能不知道提交失败（不可靠）。

使用手动提交，消费消息成功后再提交偏移量，避免了消息丢失问题，当仍存在重复消费的问题。为了解决重复消费的问题，需要消费者做幂等保障，例如唯一ID去重

适用场景：

- 提高性能：可以批量提交偏移量，减少与 kafka 的网络通信开销
- 处理复杂的消息依赖关系：可能需要确保只有当一组消息被成功处理后，偏移量才会被提交
