# 网络同步

[TOC]

## 概念

**网络同步** = 实时的多端数据同步 + 实时的多端表现同步

- 实时性：在电子竞技中，0.1 秒的延迟就可以改变局势；而 2 秒才能点开微信文章也是可以容忍的
- 多端：为了让多个客户端的显示一模一样，需要把其他玩家的数据也一起发给你；而大部分互联网产品都是针对个人用户的，不需要不同的客户端保持一致
- 表现同步：每个客户端以相同的顺序播放一连串的内容。由于网络延迟，同一个时刻不可能完全一样

**快照**

任意给定时刻记录设备的状态并在设备出现故障时进行还原

## 目标

时刻保证多个客户端的游戏表现完全一致

## 同步方式的核心差异

### 帧同步

#### 原理

客户端各自模拟，服务端也可以运行模拟用于防作弊

各个客户端有相同的初始状态，在输入相同的情况下，各个客户端的模拟结果都相同，客户端的表现也相同[^1]。按这个流程一帧一帧执行，直到游戏结束。

帧同步的核心就是确保每帧（逻辑帧）输入一致，再利用状态机的确定性，就能实现每个玩家界面上呈现的东西是一模一样的

#### 实现

（1）Deterministic Lockstep 每帧锁定

原理：每帧都要等收到所有客户端的输入才能推进到下一帧

缺点：网络差的玩家会影响其它玩家的体验；只要有一个玩家掉线，游戏就无法继续进行

![20240811180055-2024-08-11](https://raw.githubusercontent.com/YanQiu0207/image/main/20240811180055-2024-08-11.png)

（2）Bucket 同步

类似于关键帧锁定 + 乐观帧锁定

原理：

- 每帧有固定时长
- 对当前的所有命令延迟 x 帧执行以对抗网络延迟。只要在 x 帧的时间内收到所有客户端的输入就不会影响游戏的推进
- 超过这个 x 帧没有接收输入的就默认无输入，自动进入下一帧

优点：降低了网络差或掉线的玩家对其他玩家的影响

特点：x 值越小，操作反馈延迟越低，对网络抖动越敏感；x 值越大，操作反馈延迟越高，对网络抖动越适应

改进：服务器可根据各个客户端的最大 RTT 来动态调整 x 的值。网络好，x 值小；网络差，x 值 大

（3）Pipelined 流水线

如果当前玩家的指令行为不与其他人产生冲突，就可以连续的发送的自己的指令而不需要等待其他人的消息

（4）TimeWarp 时间扭曲

原理：多个物体同时进行模拟（按流水线模式），当一个物体收到了一个过去某个时刻应该执行的事件时，他应该回滚到那个时刻的状态，并且回滚前面所有的行为与状态，重新执行该事件

（5）分离渲染与逻辑

早期的 lockstep 里面渲染和逻辑都是放在一个帧里面去处理的，这样一旦命令受到网络延迟的影响，玩家本地就会卡在一个画面直到消息的到来。为了解决这个问题，有一些游戏会将逻辑和渲染分开处理（分为逻辑帧和渲染帧），**逻辑帧每隔固定的时间去处理所有逻辑事件**。在不是严格锁帧的情况下，你本地即使没有收到网络数据也可以在继续执行其他的逻辑并维持高频率的渲染（正在移动的对象不会由于短暂的延迟而静止不动）。这里面的逻辑帧就是 lockstep 里面的“Step”，也可以叫做“turn”，“bucket”或者“步”。

#### 优点

保证每个玩家界面上呈现的东西是一模一样的

（1）开发效率比较高

开发思路完全就跟写单机一样，你只需要遵从这样的思路，尽量保证性能，程序该怎么写就怎么写

（2）能实现更强的打击感或精确性

打击感强除了我们说的各种反馈、特效、音效外，还有它的准确性。利用帧同步，游戏里面看到这些挥舞的动作，就能做到在比较准确的时刻产生反馈，以及动作本身的密度也可以做到很高的频率，这在状态同步下是比较难做的。

（3）流量消耗是稳定的

同步的是玩家操作，只会随着玩家数量的增多，流量才会增长，如果玩家数量固定的话，不管你的游戏有多复杂，你的角色有多少，流量消耗基本上都是稳定的

（4）方便实现观战与录像

更方便地实现观战，录像的存储、回放，以及基于录像文件的后续处理

#### 缺点

（1）网络要求比较高
网络较差的玩家会影响其它玩家的游戏体验。因为必须收集完所有玩家的操作才能推进到下一帧，如果有个客户端网络延迟较高，其它玩家必须等他，类似一种停等协议

优化方法：使用关键帧锁定、乐观帧锁定、分离渲染与游戏逻辑、客户端预执行、指令流水线化、操作回滚

（2）很难保证确定性
即使每帧输入一致，各个客户端计算出的结果也可能不一样，影响因素有

- 浮点数计算的偏差。优化：所有运算都是基于整数，没有浮点数，浮点数用分子，分母表达。
- 随机数计算不统一。优化：游戏开始前服务端统一下发随机种子，保持各个端的随机种子一致
- 容器排序的不确定性。优化：采用确定性排序算法
- 逻辑要『我』解耦，避免走到不同的分支
- RPC 的时序
- 物理引擎

另外，要提升发现不同的问题的能力，什么时候不同步了，不同步在什么点

（3）反外挂能力很弱

帧同步的逻辑都在客户端，可以比较容易修改它

（4）逻辑性能优化有很大的压力

逻辑都是在客户端进行计算的，对客户端的性能要求高

（5）断线重回时间很长

服务器发送之前保存的指令，客户端重头开始模拟，计算量太大

> 优化：除了保存指令外，还可以定时保存快照。重回后，将最近依次的快照作为基础数据，依次执行快照之后的指令，就可以恢复到断线前的状态

#### 适用场景

对画面有精确性要求的，例如格斗类（拳王、街霸等）、体育类（篮球、足球、羽毛球等）、动作类（鬼泣）和实时策略游戏（星际、魔兽等）

人数不能太多

### 状态同步

#### 原理

**服务端模拟**，客户端也可以模拟（预测先行）

服务端结果是权威结果，服务端在合适时间向各个客户端同步差异化的结果；客户端画面不保证一致

> 什么情况下客户端画面不一致？

#### 实现

『状态同步』传递的内容以状态信息（即计算后的结果）为主，收到信息的另一端只需要和解同步过来的状态即可，不需要在本地通过处理其他端的输入信息来进行持续地模拟

同步的内容主要是：

- 基于对象的属性同步（增量状态同步）
- 通过调用产生的事件同步（RPC）

![20240811180126-2024-08-11](https://raw.githubusercontent.com/YanQiu0207/image/main/20240811180126-2024-08-11.png)

（1）客户端预测与回滚

预测：客户端立刻对玩家输入进行本地响应，提高游戏体验，以降低网络延迟带来的困扰。为了提高客户端预测的准确率，客户端与服务器应该共用一套代码以保证逻辑一致

回滚：如果玩家本地的预测结果与服务器结果一致，那么玩家不会受到任何影响。如果不一致，该怎么办呢？

对于本地角色的大体方案是：

（1）把玩家本地预执行的指令都记录好时间戳并存放到一个 MOVE BUFFER 列表里（类似一个滑动窗口）
（2）如果服务器的计算结果与你本地预测相同，可以回复你一个 ACKMOVE，你可以把 MOVE BUFFER 里面的数据从表里面移除
（3）如果服务器发现你的某个移动位置有问题时，会把该指令的时间戳以及正确的位置打包发给你。当你收到错误纠正信息时就需要本地回滚到服务器指定的位置同时把错误时刻后面 MOVE BUFFER 里面的指令重新执行一遍

为什么不直接拉回？【不太理解】
因为这时候他想纠正的是之前的错误而不是现在的错误，如果简单的拉回就会让你觉得被莫名其妙的拉回到以前的一个位置。同时，考虑到已经在路上的指令以及后续你要发送的预测指令，会让服务器后续的校验与纠正变得复杂且奇怪

![20240812000508-2024-08-12](https://raw.githubusercontent.com/YanQiu0207/image/main/20240812000508-2024-08-12.png)

（2）时间同步

Jim Greer 等人提出了『消除高阶的流式时间同步』，算法精髓在于丢弃和中间值偏差超过一个标准偏差的数值。其目的是为了去除 TCP 中重传的数据包

（3）插值技术

- 内插值：通过已知的、离散的数据点，在范围内推求新数据点的方法（模拟在点间的移动路径）

- 外插值（外推）：从已知数据的离散集合中构建超出原始范围的新数据的方法，也可以指根据过去和现在的发展趋势来推断未来

在游戏中，一般以简单的线性插值或多项式插值为主

对于其它角色的移动预测，常用的是导航推测（Dead Reckoning）：

（1）给定一个坐标点以及当前的方向和速度等信息，推测其之后的移动路径
（2）如果服务端发来的位置与客户端预测的位置可能不一致，此时需要对客户端表现进行修正。为了避免位置突变，客户端会采用内插值的方式将其它角色从预测位置平滑地过渡到真实位置，保证本地角色的客户端能有流畅的表现

![20240812003009-2024-08-12](https://raw.githubusercontent.com/YanQiu0207/image/main/20240812003009-2024-08-12.png)

（4）延迟补偿

玩家本地的时间总是领先于服务器，玩家开枪的时间到服务器执行时就一定会被延迟，所以为了尽量减小延迟所带来的问题，他们提出了一种名为延迟补偿的技术

服务器记录一段时间内所有玩家的位置历史，在发生伤害计算时根据延迟对所有玩家角色进行位置的回滚与处理（注意：计算后服务器立刻还原其位置），可以尽量还原当时的场景

延迟补偿并不是一个万能的优化方式，采用与否应该由游戏的类型与设计决定。考虑一个 ACT 类型的网游，玩家 A 延迟比较低、玩家 B 延迟比较高。在 A 的客户端上，玩家 A 在 T1 时间靠近 B，而后立刻执行了一个后滚操作，发送到服务器。在 B 的客户端上，同样在 T1 时间发起进攻，然后发送命令到服务器。由于 A 的延迟低，服务器先收到了 A 的指令，A 开始后滚操作，这时候 A 已经脱离了 B 的攻击范围。然后当 B 的指令到达服务器的时候，如果采用延迟补偿，就需要把 A 回滚到之前的位置结果就是 A 收到了 B 的攻击，这对 A 来说显然是不公平的。如果该情况发生在 FPS 里面，就不会有很大的问题，因为 A 根本不知道 B 什么时候瞄准的 A

![20240812003042-2024-08-12](https://raw.githubusercontent.com/YanQiu0207/image/main/20240812003042-2024-08-12.png)

#### 优点

（1）对于网络的带宽和抖动包有更强的适应能力

即便出现了 200、300 的输入延迟再恢复正常，玩家其实也感受不到不太舒服的地方

（2）安全性非常高

外挂基本上没有什么能力从中收益

（3）断线重连比较快

如果我的游戏崩溃了，客户端重启之后只需要服务器把所有重要对象的状态再同步一次过来，重新再创建出来就可以了

（4）客户端性能优化优势也比较明显

比如优化时可以做裁剪，玩家看不到的角色可以不用创建，不用对它进行运算，节省消耗

#### 缺点

（1）开发效率相对帧同步而言要差一些

很多时候你需要保证服务器与客户端的每一个角色对象的状态之间保持一致，但事实上你很难做到一致

（2）比较难做出动作类游戏打击感和精确性

比如说你要做一个射击类角色，他的子弹每秒钟要产生几十颗，基于状态同步来做是比较难的，因为系统在很短时间内，会产生很多数据，要通过创建、销毁、位置运算来同步

（3）流量会随着游戏的复杂度，而逐渐增长，比如角色的多少

### 快照同步

#### 原理

**服务端模拟**，客户端基本不模拟

服务端定时同步整个游戏世界所有物体的状态给每个客户端，而客户端相当于一个播放器，通过插值的方式来使得视觉平滑

#### 优点

对客户端的性能要求较低

#### 缺点

太浪费带宽，主要是

- 玩家视野是有限的，不需要给他发送整个世界的状态
- 每次发送的快照跟之前的快照有相当多的重复，实际只需要发送变化的数据

#### 适用场景

适用于运行在客户端性能较低的游戏，例如云游戏

适用于物体比较少的游戏，例如小游戏

> 状态同步是快照同步的优化

## 常见的优化技术

优化的目的：降低或抵消网络延迟

常见手段：表现优化、延迟对抗、丢包对抗、带宽优化和帧率优化

（1）表现优化（弱化玩家对延迟的感受）

a. 插值优化

通过内插值解决客户端信息离散更新的突变问题

通过外插值解决网络延迟过大收不到数据导致卡顿的问题

两者可以同时使用。在具体应用时，需要分离逻辑帧和渲染帧，这样客户端在没有收到数据时还可以继续更新渲染

b. 客户端预先执行 + 回滚

预先执行的目的是玩家在本地操作后能立刻收到反馈，提升游戏体验；回滚是保证服务器的权威性

（2）延迟对抗（弱化玩家对延迟的感受）

a. 延迟补偿

服务器记录一段时间内所有玩家的位置历史，在发生伤害计算时根据延迟对所有玩家角色进行位置的回滚与处理（注意：计算后服务器立刻还原其位置），可以尽量还原当时的场景

b. 命令缓冲区

把远端数据缓存在一个 buffer 里面，然后按照固定频率从 buffer 里面取，可以解决客户端卡顿以及网络抖动问题

缓冲区大小与延迟是冲突的：缓冲区越大，延迟越大，对网络抖动有更强的适应性；缓冲区越小，延迟越小，容易受网络影响而卡顿

c. 从具体实现技巧上对抗延迟

操作前增加一个前摇时间以抵消网络延迟

例如玩家扔手雷时，客户端立刻播放扔手雷的前摇画面并发送请求到服务器，服务器收到后进行判断并同步给客户端，客户端收到消息真正扔出手雷。在玩家看来，这种表现就是零延迟的

（3）丢包对抗（弱化玩家对延迟的感受）

a. 优先使用 TCP 而不是 UDP

对于延迟不敏感的游戏还是优先采取 TCP 来对抗丢包

b. 冗余 UDP 数据包

可以采用冗余 UDP 的方案，即后续的 UDP 包会冗余一定量的前面已发送的 UDP 包，这样即使丢失了部分包我们也能保证拿到完整的远端数据

（4）带宽优化（减小延迟）

a. 同步对象裁剪

剔除不需要同步的对象，减少需要同步的对象数量，例如 AOI 算法

b. 数据压缩与裁剪

在状态同步里，第一次发送完整的数据信息，后续只发送变化的数据，减少每个对象的同步数据量

只同步需要的数据

c. 减少遍历以及更细粒度的优化

快速定位需同步的对象

快速定位需同步的数据

d. 分区、分房间

将玩家分散到不同的场景内，减少服务器处理数据的压力，减小延迟

同一个地图的不同区域由不同服务器负责接管，但边界问题不好处理

（5）帧率优化（减小延迟）

a. 提升帧率

b. 保持帧率稳定与匹配

c. 计算压力分担

## 参考资料

- [王者技术修炼之路](https://youxiputao.com/articles/11842)

- [细谈网络同步在游戏历史中的发展变化（上）](https://zhuanlan.zhihu.com/p/130702310)
- [细谈网络同步在游戏历史中的发展变化（中）](https://zhuanlan.zhihu.com/p/164686867)
- [细谈网络同步在游戏历史中的发展变化（下）](https://zhuanlan.zhihu.com/p/336869551)

- [关于“帧同步”说法的历史由来](https://zhuanlan.zhihu.com/p/165293116)
- [再谈网游同步技术](https://www.skywind.me/blog/archives/1343)
- [服务端十二小时（百度网盘提取码:2j9b）](https://pan.baidu.com/share/init?surl=oBvmdQgsUWKrmU8g9o3u5Q)
- [帧锁定同步算法](https://www.skywind.me/blog/archives/131)
- [帧同步游戏中使用 Run-Ahead 隐藏输入延迟](https://www.skywind.me/blog/archives/2746)
- [影子跟随算法（2007 年老文一篇）](https://www.skywind.me/blog/archives/1145)


- [网络游戏同步技术一：分类及差异](https://zhuanlan.zhihu.com/p/697083500)
- [网络游戏同步技术二：状态同步的优化与实现](https://zhuanlan.zhihu.com/p/697158275)
- [网络游戏同步技术三：拓展阅读](https://zhuanlan.zhihu.com/p/697165259)
- [网络游戏同步技术四：方案选择](https://zhuanlan.zhihu.com/p/697199113)
- [网络游戏同步技术五：帧同步的实现与优化](https://zhuanlan.zhihu.com/p/697213631)
- [网络游戏同步技术六：若干问题探讨](https://zhuanlan.zhihu.com/p/697218660)

[^1]: 各个客户端每帧播放的内容相同，但由于网络延迟和客户端性能差异，播放时间有先后是不可避免的
