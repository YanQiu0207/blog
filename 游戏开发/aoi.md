# AOI

AOI，全称为 Area Of Interest，翻译为 **感兴趣的区域**，通俗地讲是一个对象在场景中的视野。它能观察到视野中其它对象的一举一动，同时它也在某些对象的视野中，也被这些对象观察着

AOI 的核心是位置管理，其作用是：

- 优化数据发送，减少通信量。离得太远的玩家不需要发送数据
- 为位置相关操作提供支持。例如玩家技能打出去，需要知道自己周围有哪些玩家和怪物

通常每个对象需要维护两个集合：

* **观察者集合**：即观察我的对象的集合，我所有的 AOI 行为都需要向这个集合发送，以便让他们观察到我的变化
* **被观察者集合**：即被我观察的对象的集合。有了观察者集合，为什么还要维护一个被观察者集合呢？有些情况下，某个对象的这两个集合不一定是相等的。比如两个对象的视野不一样，A 能看到 B，B 看不到 A，那么 B 的观察者集合中有 A，B 的被观察者集合中无 A

比如，当 B 进入 A 的视野，A 的被观察者集合中要加上 B，B 的观察者集合中要加上 A。如果同时 A 也进入了 B 的视野，那么 B 的被观察者集合加上 A，A 的观察者集合加上 B

因此，AOI 算法的设计需要考虑：

- 对象的视野大小，这直接关系到集合的大小
- 对象触发进入、离开、移动事件时，如何更新集合
- 对象集合保存在哪里？是所有对象共享集合，还是每个对象单独保存集合

高效的 AOI 算法需要考虑：

- 尽量减少同步的对象数量，即减小视野范围
- 高效地获取同步的对象集合，尽量减少遍历次数。理论上，时间复杂度最好能做到 `O(1)`，这可能需要空间来换

## 全场景广播

全场景可见：整个场景都是可见范围，无论我走到哪里，都能看到场景中的每个对象

实现：只需用一个字典保存所有游戏对象，被观察者集合和观察者集合直接从字典中取

优点：

- 简单，不容易出错
- 高效，也不需要每个对象单独保存被观察者集合和观察者集合

缺点：

当场景中对象数量达到上千时，

- 每个对象的状态更新都要通知上千个其它对象，交叉起来能达到百万级别的量
- 客户端承受不了上千的游戏对象

适用场景：场景中的对象只有几十个

优化方向：减少对象的数量。解决办法：减小对象的视野

## 减小视野

一旦限定对象的视野，AOI 算法就变得复杂

- 每种对象的视野大小不同
- 每个对象需各自维护被观察者集合和观察者集合

优点：减少了同步的对象数量

缺点：无法高效地获取同步的对象集合。其中，移动是最大的性能瓶颈，每次移动都需要遍历场景中的所有对象。如果每个对象都在移动，消息量级是对象数量的平方

优化方向：减少遍历。解决办法：将场景划分格子

## 网格化

**实现**

- 将场景划分为等大的格子
- 每个进入场景的对象根据坐标加入对应的格子中
- 如果把最大视野限定为 9 宫格，这样搜索范围就缩写小为 9 个格子，需要遍历的对象数量大大减少

**进入**

我进入场景，根据坐标计算出所在格子，并加入这个格子

取出周围格子的对象，给我发送它们的 Enter 事件，同时给它们发送我的 Enter 事件

**离开**

我离开场景，将我从格子中删除

取出周围格子的对象，给它们发送我的 Leave 事件。这里不需要给我发送它们的 Leave 事件，因为客户端进入新场景后会自动释放旧场景的资源

**移动**

如果没跨格子，直接取周围格子的对象，向它们发送 Move 事件

如果跨过格子，

- 计算 {OldGrid - NewGrid}，向它们发送我的 Leave 事件
- 计算 {NewGrid - OldGrid}，向它们发送我的 Enter 事件
- 计算 {OldGrid & NewGrid}，向它们发送我的 Move 事件

**更新**

取出周围格子的对象，给它们发送我的 Update 事件，例如造型变化

**总结**

（1）实际使用
一般，玩家的屏幕大小是 9 宫格，服务端同步给客户端的视野范围是 25 个格子

这是为了给玩家更顺滑的游戏体验。玩家移动时，客户端先预表现再通知服务端，服务端再执行 AOI 运算，发包给客户端。如果不提前同步，那么玩家移动时就会发现某个位置原本是空白的，然后突然间出现了玩家或 NPC

（2）适用场景
场景足够大且对象均匀地分布在场景中，那么网格化算法非常高效

如果玩家集中在一个区域，即几个格子的玩家占了场景 80% 的玩家，服务器的同步压力很大。虽然，获取同步的对象集合很高效，但是同步的对象数量很多，极端情况下消息数量级是玩家数量 n 的 `O(n^2)`

（3）人数过多

- 场景分线：把玩家分到不同的场景，每个场景有人数上限，保证每个场景的负载不会那么高
- 场景分层：角色进入这个场景后，由不同的层对象管理，即使在同一个场景，也可能看不到对方，达到减少 AOI 消息的目的
- 增大格子：同样的视野范围，增加格子的大小，格子数就会变少。每个格子能看到的人数有上限，那么玩家能看到的玩家数也会减少

（4）优缺点

**优点**

实现简单、性能高

**缺点**：

- 流量洪峰：玩家跨越格子时，会有 5 个格子的对象退出视野，有 5 个格子的对象进入视野，这个瞬间会出现流量洪峰，导致客户端卡顿或卡死

- 流量浪费：为了让玩家在格子的边缘能有完整的视野，客户端的可见区域不能大于 4 个格子的范围。在 3D 游戏里面，玩家真正的可见区域其实是一个梯形，比 4 个格子的范围更小。通过面积来测算，我们也可以看到至少会有 60% 的同步对象客户端是看不到的。既然这些对象看不到，我们为什么要进行同步？

- 不适合做可变视野，流量浪费严重

- 不适合 3D。真要做，类似于正方体，27 个小正方体组成

## 十字链表

核心思想：

- 将所有对象节点链接到两个链表上，一个按 X 值排序，一个按 Y 值排序
- 对象进入场景后，遍历两个链表，找到合适的位置插进去
- 移动的时候，从对象前后位置遍历两个链表进行判断

因为每个对象的视野可能不一样，没法只前后遍历一点点，有可能在很远的地方某个对象在观察着你，你只能遍历整个链表。解决办法：

- 每个对象都带有两个哨兵节点，它们也被链接到两个链表上，它们的坐标与对象坐标的差值等于视野半径
- 对象节点移动时，哨兵节点也跟着移动
- 哨兵节点或对象节点移动时，会跨越对方，在跨越的时候判断进入视野还是离开视野。每个对象各自维护被观察者集合和观察者集合

**哨兵节点减少了移动时的遍历次数**

但十字链表在玩家经常进出场景的情况下表现得不太好，

- 玩家每次进入场景，都需要从 X 和 Y 的链表头开始遍历，直到找到自己的位置，时间复杂度是 `O(N)`
- 玩家每次出场景，也需要从 X 和 Y 的链表头开始遍历，直到找到自己的位置 - 最大视野直径的位置，时间复杂度是 `O(N)`

解决办法：

- 首先需要像 9 宫格那样**限定一个最大视野**，比如任何对象的视野都不会超过 1.5 个屏幕大小

- 定义一些地标结点，它们的坐标在设定之后就不会改变，像是地图里的地标一样。假如一个地图的大小是 1000x1000，我们可以创建 10 个地标结点，每个结点的坐标相距 100 大小：M1(0, 0), M2(100, 100), M3(200, 200), M4(300, 300)。创建场景的时候，就把地标结点分别插入到 X 和 Y 链表中，地标结点的坐标不会改变，所以永远不用移动它们

- 把这些地标结点按顺序保存在一个数组中：|M1|M2|M3...|，有了这个数组，我们就不用从头移动了

- A 进入场景后，它算出：**移动点 = A 的坐标 - 最大视野直径**，然后在地标数组中快速查找到最近的地标结点 (哈希取余)，从这个地标结点开始向前移动，移动过程中 A 就会进入其他对象的视野

- A 移动完成之后，A 身边的两个哨兵结点开始向两边移动，移动过程中就会有一些对象进入 A 的视野

**地标节点减少进入场景时的遍历次数**

**退出场景并不需要遍历链表，直接根据对象的观察者集合和被观察者集合进行处理即可**

> 如果对象的类型和视野大小有限制，应该是能够缩小遍历范围的。不过，这也会限制业务的使用

适用场景

对象经常静止或小幅移动，对于大幅移动和进出场景是小概率事件

优缺点：

优点：

- 适合可变视野
- 适合 3D 游戏

缺点：

- 对象大幅移动时效率低

## 参考资料


