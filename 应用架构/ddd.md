# DDD

[TOC]

## 应用架构

### 如何去评价一段代码

解决传统架构中的问题，包括维护性，扩展性，可测试性，代码结构清晰（快速定位到相关代码）

（1）可维护性
当依赖变化时，有多少代码需要随之改变

一个应用最大的成本不是来自开发阶段，而是应用整个生命周期的总维护成本

外部依赖包括中间件更换；第三方服务接口变化，不可控，限流和熔断；依赖库的升级；数据结构的不稳定性

（2）可扩展性
做新需求或者改逻辑时，需要新增或修改多少代码

做第一个需求非常快，但做第 N 个需求的时间可能呈指数增长，绝大部分时间花在老代码的重构和兼容上

数据来源被固定；数据格式不兼容；业务逻辑无法复用；逻辑和数据存储的相互依赖

（3）可测试性

可测试性=运行每个测试用例所花费的时间*每个需求所需要增加的测试用例数量

bug 往往来源于未被覆盖到的情况

原因：设施搭建困难，运行耗时长，耦合度高

### 代码组织结构

待续

### 领域驱动

越外层越稳定，越内层代码演进速度越快，真正体现领域驱动的核心思想

考虑到最终的依赖关系，我们可能先写 Domain 层的业务逻辑，然后再写 Application 层的组件编排，最后才写每个外部依赖的具体实现。这种架构思路和代码组织结构就叫做 Domain-Driven Design（领域驱动设计，或 DDD）。

### 可测试性

100% 被单测覆盖

## 领域层

### 实体类（Entity）

DDD 架构的核心是实体类，实体类包含了一个领域里的状态，以及对状态的直接操作

实体类最重要的设计原则就是保证实体的不变性，也就是说要**保证无论外部怎么操作，一个实体内部的属性都不能出现互相冲突，状态不一致的情况**

设计原则：

（1）创建即一致

问题：调用方手动 new 一个模型，再一个个参数赋值，很容易产生遗漏

解决办法：

- 构造函数要包含所有属性，或者有合理的默认值。构造函数里需要对属性进行强校验（assert）
- 使用设计模式来降低调用方的复杂度，例如工厂模式、建造者模式、原型模式等

（2）尽量避免 public setter

问题：实体暴露了 public 的 setter 方法，特别是 set 单一参数很容易导致状态不一致

解决办法：

- 在实体里，要通过行为方法来修改内部状态
- 即使是简单场景，也建议使用比较「行为化」的命名，增强语意

（3）通过聚合根保证主子实体的一致性

在复杂一点的领域，通常主实体会包含子实体，这时候主实体就需要起到聚合根的作用

子实体不能单独存在，只能通过聚合根的方法获取到。任何外部的对象都不能直接保留子实体的引用。如果外部对象可以直接调用子实体的方法可能会导致状态不一致，
因为这些更改可能没有通过聚合根进行统一管理。正确的做法是通过聚合根来与子实体交互。聚合根提供了对子实体的操作方法，并负责保持聚合内部状态的一致性

子实体没有独立的 Repository，不可以单独保存和取出，必须要通过聚合根的 Repository 实例化

子实体可以单独修改自身状态，但是多个子实体之间的状态一致性需要聚合根来保障

（4）不可以强依赖其他聚合根实体或领域服务

一个实体类不能直接在内部直接依赖一个外部的实体或服务

原因：对外部对象的依赖性会直接导致实体无法被单测；以及一个实体无法保证外部实体变更后不会影响本实体的一致性和正确性

正确做法：

- 只保存外部实体的 ID
- 针对于「无副作用」的外部依赖，通过方法入参的方式传入
- 如果方法对外部依赖有副作用，不能通过方法入参的方式，只能通过 Domain Service 解决

（5）任何实体的行为只能直接影响到本实体（和其子实体）

任何实体的行为不能直接修改其它的实体类

原因：确保代码可读性、可理解的原则；降低未知的变更的风险

### 领域服务（Domain Service）

（1）单对象策略型

面向的是单个实体对象的变更，但涉及到多个领域对象或外部依赖的一些规则

（2）跨对象事务型

当一个行为会直接修改多个实体时，不能再通过单一实体的方法作处理，而必须直接使用领域服务的方法来做操作，确保多个实体的变更之间是有一致性的

（3）通用组件型

像 ECS 里的 System，提供了组件化的行为，但本身又不直接绑死在一种实体类上

### 领域原语（Domain Primitive）

定义：特定领域内，拥有精准定义，可自我验证，拥有行为的 value object

原则：将隐性的概念显性化；将隐性的上下文显性化；封装多对象的行为

应用场景：有行为和验证要求的基础类型

### 策略对象（Domain Policy）

核心用途就是封装领域规则

一个 Policy 是一个无状态的单例对象，通常需要至少 2 个方法：canApply 和 一个业务方法

其中，canApply 方法用来判断一个 Policy 是否适用于当前的上下文，如果适用则调用方会去触发业务方法

为了降低一个 Policy 的可测试性和复杂度，Policy 不应该直接操作对象，而是通过返回计算后的值，在 Domain Service 里对对象进行操作

扩展：

- 通过不同的 Priority 方案对 Policy 进行排序
- 通过 Java 的 SPI 机制或类 SPI 机制注册 Policy

### 领域事件（Domain Event）

领域事件是一个在领域里发生了某些事后，希望领域里其他对象能够感知到的通知机制

反应代码（比如升级）直接和上面的事件触发条件（比如收到经验）直接耦合，而且这种耦合性是隐性的。领域事件的好处就是将这种隐性的副作用「显性化」，通过一个显性的事件，将事件触发和事件处理解耦，最终起到代码更清晰、扩展性更好的目的

## 接口层

（1）作用

- 负责网络协议的转化，解耦业务代码和网络协议，避免两者绑定导致业务代码无法被复用【**尝试应用**】
- 处理业务无关的内容，包括统一鉴权、会话管理、缓存、限流、监控和警报、异常处理等【**尝试应用**】

（2）返回值和异常处理规范

> 本部分内容针对 REST 和 RPC 接口，其它协议根据协议规范产生返回值

问题：接口层的核心价值是对外，所以如果只是返回 DTO 或 DO 会不可避免地面临异常和错误栈泄漏到使用方的情况，包括错误栈被序列化反序列化的消耗

提出**规范**：
- 接口层的 HTTP 和 RPC 接口，返回值为 Result，捕捉所有异常
- 应用层的所有接口返回值为 DTO，不负责处理异常，方便知道错误的来源和堆栈

（3）接口的数量和业务间的隔离

问题：传统实现，追求一个领域的方法应放在一个服务或 Controller 中，但当支撑的上游业务比较多时，刻意去追求接口的统一会导致方法中的参数膨胀，或者导致方法数量的膨胀

提出**规范**：一个接口层的类应该是小而美的，应该是面向一个单一的业务或一类同样需求的业务，需要尽量避免用一个类承接不同类型业务的需求

好处：符合单一职责原则，即一个接口类仅仅会因为一个或一类业务的变化而变化。当业务需求快速变化时，接口层也跟着快速变化，通过独立的接口类可以避免业务间相互影响。当一个现有的接口类过度膨胀时，可以考虑对接口按单一职责原则进行拆分

疑问：这种做法会产生大量的接口类，导致代码逻辑重复吗？
答案是不会。因为接口类的核心作用仅仅是协议层，真实的业务逻辑会沉淀到应用层，也就是说接口层和应用层是多对多的关系

实现：通过 AOP 统一处理，避免代码里有大量重复代码

## 应用层

（1）核心类

- ApplicationService 应用服务：最核心的类，负责业务流程的编排，但本身不负责任何业务逻辑
- Command、Query、Event 对象：作为 ApplicationService 的入参
- 返回的 DTO：作为 ApplicationService 的出参
- DTO Assembler：负责将内部领域对象转化为对外的 DTO

（2）Command、Query、Event 对象【**尝试应用**】

语意总结：

- Command
  - 语意：「希望」能触发的操作
  - 读/写：写
  - 返回值：DTO 或 Boolean
- Query
  - 语意：各种条件的查询
  - 读/写：只读
  - 返回值：DTO 或 Collection
- Event
  - 语意：已经发生过的事
  - 读/写：通常是写
  - 返回值：无

为什么要用 CQE 对象？传统写法的缺点：

- 接口膨胀：一个查询条件一个方法
- 难以扩展：每新增一个参数都有可能需要调用方升级
- 难以测试：接口一多，职责随之变得繁杂，业务场景各异，测试用例难以维护
- 无语意：只是一堆参数的罗列而已，无法明确地表达业务意图

CQE 的**规范**：ApplicationService 的接口入参只能是一个 Command、Query 或 Event 对象，CQE 对象需要能代表当前方法的语意。唯一可以的例外是根据单一 ID 查询的情况，可以省略掉一个 Query 对象的创建

CQE 的校验：传统写法将校验逻辑放在 ApplicationService，大量的非业务代码混杂在业务代码中，很明显的违背了单一职责原则。可以利用 java 标准 JSR303 或 JSR380 的 Bean Validation 来前置这个校验逻辑，让 ApplicationService 更加清爽，同时各种错误信息可以通过 Bean Validation 的 API 做各种个性化定制

避免复用 CQE：哪怕所有的参数都一样，只要他们的语意不同，尽量还是要用不同的对象

（3）ApplicationService 【**尝试应用**】

作用：负责业务流程的编排，但本身不负责任何业务逻辑，是“胶水层”代码

组织形态：一个 ApplicationService 类是一个完整的业务流程，其中每个方法负责处理一个 Use Case
好处是可以完整收敛整个业务逻辑，从接口类即可对业务逻辑有一定的掌握，适合相对简单的业务流程
坏处就是对于复杂的业务流程会导致一个类的方法过多，有可能代码量过大

怎么判断一段代码到底是业务流程还是逻辑呢？

- 不要有 if/else 分支逻辑。如果有，应该封装到 DomainService 或 Entity 中。例外：分支判断仅仅代表了中断条件，具体的业务处理逻辑没有受影响，也是合理的
- 不要有任何计算。如果有，应该封装到 DomainService 或 Entity 中
- 一些数据转化可以交给其它对象来做。例如 DTO Assembler 负责将内部领域对象转化为对外的 DTO

（4）DTO Assembler

**规范**：ApplicationService 应该永远返回 DTO 而不是 Entity

DTO Assembler 通常不建议有反操作，也就是不会从 DTO 到 Entity，因为通常一个 DTO 转化为 Entity 时是无法保证 Entity 的准确性的

推荐 MapStruct 这个库实现 Entity 转 DTO，避免手写转换代码容易出错，且性能损耗可忽略不计（生成静态代码直接赋值）

（5）异常

**规范**：Application 层只返回 DTO，可以直接抛异常，不用统一处理。所有调用到的服务也都可以直接抛异常，除非需要特殊处理，否则不需要刻意捕捉异常

异常的好处是能明确的知道错误的来源，堆栈等，在接口层统一捕捉异常是为了避免异常堆栈信息泄漏到 API 之外

（6）ACL 防腐层【**尝试应用**】

问题：因为自己的代码强依赖了外部系统，所以会随外部系统的变化而变更，这个在复杂系统中应该是尽量避免的。需要将外部依赖转为内部代码，隔离外部的影响

原理：

- 对于依赖的外部对象，我们抽取出所需要的字段，生成一个内部所需的 VO 或 DTO 类
- 构建一个新的 Facade，在 Facade 中封装调用链路，将外部类转化为内部类
- 针对外部系统调用，同样的用 Facade 方法封装外部调用链路

（7）业务流程设计模式【**尝试应用**】

两种模式：

- 编排：一个服务直接调用另一个服务；调用方强依赖服务提供方；调用方为整个业务流程负责
- 协作：每个服务最好自己的事，然后通过事件触发其它服务；下游依赖上游的代码（事件类）；没有谁会为整体流程负责

编排和协作模式的对比

|  | 编排 | 协作 |
|--|--|--|
| 驱动力 | 指令驱动 | 事件驱动 |
| 调用依赖 | 上游依赖下游 | 无直接调用依赖，但是有代码依赖，可以认为是下游依赖上游 |
| 灵活性 | 较差 | 较高 |
| 业务职责 | 上游为业务负责 | 无全局负责人 |

如何选择？

- 明确依赖的方向
- 找出业务中的『负责人』

哪个模式更好？

没有最好的模式，只有最适合自己业务场景的模式

## 扩展

### ECS

（1）基本概念

- Entity: 代表一个游戏对象，最重要的是 Entity ID，一个 Entity 里包含多个 Component
- Component: 真正的数据，把一个 Entity 的数据拆分为多个 Component
- System：真正的行为，每个 System 都只负责一件事，可以依次处理大量相同的 Component，而不需要去理解具体的 Entity

（2）核心思想

- 组件化：将一个游戏对象的数据和行为拆分为多个组件和组件系统，能实现组件的高度复用性，降低重复开发成本
- 行为抽离：将通用逻辑抽离出来成为单独的 System 类，可以明显提升代码的可读性；抽离了一些和对象代码无关的依赖
- 数据驱动：一个对象的行为不是写死的，而是通过参数决定。通过动态修改参数，可以快速改变一个对象的具体行为

（3）问题

ECS 为了提升性能，强调数据和行为分离，并且为了降低 GC 成本直接操作数据，会影响数据的正确性，对商业应用没有太大的好处

### 思考

1. 需求分析
（1）这个系统有哪些功能？用例图或者用户故事（User Story）
（2）建立核心概念表，包括中文名、英文名和说明（例如用途）

2. 深入代码实现，提高代码的可扩展性
在需求分析时，就可以对将来可能变化的地方进行评估调整成本

3. 优先选择组合而不是继承

继承的优点：子类既可以复用父类的代码，还可以通过重写父类的方法来扩展新的行为
继承的缺点：子类依赖了父类的实现，父类的变更可能会影响所有子类

核心：继承对扩展开放，对修改没有封闭。如果变更会影响现有的代码，可能导致一些无法预见的影响，
这个风险只能通过单元测试来覆盖保障，但在实际开发中很难保证单测的覆盖率

## 参考

- [DDD 系列第一讲：Domain Primitive](https://mp.weixin.qq.com/s/kpXklmidsidZEiHNw57QAQ)
- [DDD 系列第二讲：应用架构](https://mp.weixin.qq.com/s/MU1rqpQ1aA1p7OtXqVVwxQ)
- [DDD 系列第三讲：Repository 模式](https://mp.weixin.qq.com/s/1bcymUcjCkOdvVygunShmw)
- [DDD 系列第四讲：领域层设计规范](https://mp.weixin.qq.com/s/w1zqhWGuDPsCayiOgfxk6w)
- [DDD 系列第五讲：聊聊如何避免写流水账代码](https://mp.weixin.qq.com/s/1rdnkROdcNw5ro4ct99SqQ)
