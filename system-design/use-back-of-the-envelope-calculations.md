## 封底估算

## 2 的 幂等

|2 的幂|缩写|近似值|
|---|---|---|
| 2^10 | 1 KB | 1000 |
| 2^20 | 1 MB | 1000,000 |
| 2^30 | 1 GB | 1000,000,000 |
| 2^40 | 1 TB | 1000,000,000,000 |
| 2^50 | 1 PB | 1000,000,000,000,000 |

## 每个程序员都应该知道的操作耗时

最初的数据来源于 [Teach Yourself Programming in Ten Years](http://norvig.com/21-days.html)

最新数据来自于 [Latency Numbers Every Programmer Should Know](https://colin-scott.github.io/personal_website/research/interactive_latency.html)

对比两份数据，

- 网络传输速度有了质的飞跃
- 内存、机械硬盘、SSD 的读取速度都有数量级的提升

这些数字指导我们设计性能更佳的程序

*   CPU 的执行指令速度远快于内存 IO，为了弥补两者的速度差距，加了 L1, L2 等缓存。可以把频繁访问的数据放到一起（空间/时间局部性）以充分利用 CPU 的缓存

*   频繁执行的分支应该放在前面，避免分支预测错误

*   内存 IO 远快于磁盘 IO 和网络 IO，所以应该将频繁读取的数据放到内存中

*   SSD 的读写速度远快于机械硬盘。服务器的磁盘应尽量使用 SSD 以获取更好的性能

*   顺序写远快于随机写，所以很多开源软件只做追加写操作，例如 kafka 顺序写消息，MySQL 写 WAL 日志

## 可用性相关数字

高可用性指一个服务长时间持续运转的能力。一般是用百分比来衡量，由于大部分服务的可用性在 99% 到 100% 之间，所以通常都用小数点之后 「9」 的个数来衡量可用性，「9」越多代表可用性越高

|可用性|每年不可用时长|
|---|---|
| 99% | 3.65 天 |
| 99.9% | 8.77 小时 |
| 99.99% | 52.60 分钟 | 
| 99.999% | 5.26 分钟 |
| 99.9999% | 31.56 秒 |

## 技巧

* 凑整和近似。例如 99,987 / 9.1 = 100,000 / 10 = 10000
* 写下假设以便之后做参考
* 表明单位，避免把自己搞迷糊
* 熟练掌握常用指标的计算方法，包括 QPS、峰值 QPS、存储大小、缓存大小和服务器数量等