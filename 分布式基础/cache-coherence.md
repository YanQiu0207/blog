## 缓存一致性探究

*   缓存数据一致性探究 https://mp.weixin.qq.com/s/OWuP66WxpciBAgm2mptUxw

1. 针对先更新数据库再删除缓存，如果 A 和 B 来自不同节点，发生的概率也不低
1. 
1. 如何解决缓存操作失败？一是借用消息队列实现重试；二是订阅 MySQL binlog，再操作缓存
1. 针对先更新数据库再删除缓存，缺点是命中率低，因为infant删除缓存。要想命中率高，还是得用先更新数据库后更新的方案。对于数据不一致问题，可以用版本号机制或者缩短缓存时间来缓解

## 背景

缓存的分类：

*   进程内缓存：将数据放在本地机器的内存中，节省网络 IO。由于内存大小有限，所以一般是存放最热点的数据。
*   分布式缓存：将数据放在高速 kv 存储中，避免读取慢速的关系型数据库。

缓存的使用模式：

*   旁路缓存模式（cache aside pattern）
    *   原理：读取数据，如果缓存层有数据，那么返回数据；如果没有，则从持久层读取，并写到缓存层。更新数据，先更新数据库，后删除缓存
    *   优点：提高了读取性能；持久层有最新数据，宕机也不会丢失数据，可靠性高
    *   缺点：频繁删除缓存导致命中率低
*   写穿模式（write through pattern）
    *   原理：同时写入缓存层和持久层
    *   优点：提高了读取性能；持久层有最新数据，宕机也不会丢失数据，可靠性高；缓存命中率高
    *   缺点：写入速度慢
*   写回模式（write back pattern）
    *   原理：读取数据，如果缓存层有数据，那么返回数据；如果没有，则从持久层读取，并写到缓存层，然后返回数据。写入数据，只写入缓存层就行。缓存层定时，或者数据过期时将数据写入持久层
    *   优点：提高了读取性能；写入速度快；缓存命中率高
    *   缺点：宕机丢失数据

## 一致性

客观上，MySQL 和 Redis 的不一致是没法完全避免的，因为这两个操作是没有事务保证的

哪些情况会导致 MySQL 和 Redis 的不一致？

*   因为网络分区或 Redis 节点宕机，导致数据没有更新到 Redis，与 MySQL 不一致
*   MySQL 的修改和 Redis 的修改之间存在一个短暂的时间窗口，能观察到数据不一致。如果这个窗口做到极小（1ms内），那么这个不一致的影响通常可以忽略不计

总结，虽然无法做到强一致性，但可以做到最终一致性。要求数据不一致的窗口极小，能主动发现数据的不一致。

为什么不用 2PC 或 paxos 等协议保证一致性？主要是保证了一致性但性能比不用 Redis 还低，背离了我们使用缓存的初衷，即通过数据冗余以提高数据读取性能，所以常用手段还是拼命地降低脏数据的概率

## 旁路缓存模式

先操作数据库还是先操作缓存？缓存是更新还是删除？

*   先更新数据库后更新缓存：写写冲突
*   先更新缓存后更新数据库：写写冲突；存在更新数据库失败的情况。业务上应避免使用此种情况
*   先删除缓存后更新数据库：避免了写写冲突，但存在写读冲突。有人想出了延时双删的办法，间隔时间不好确定
*   先更新数据库后删除缓存：避免了写写冲突，写读冲突，但仍然存在极小概率的读写冲突

适用场景：

*   读多写少：建议采用先更新数据库后删除缓存的策略
*   读写相当或写多读少：建议采用先更新数据库后更新缓存的策略

## 最终一致

即使不存在并发，MySQL 和 Redis 也可能不一致，例如Redis 节点宕机，导致数据没有更新到 Redis

*   设置缓存过期时间：兜底方案，有机会将数据库地最新数据写到 Redis
*   消息队列：利用 MQ 重试机制保证最后能够成功。注意，要保证写入 MySQL 和写入 MQ 是事务的
*   订阅 binlog 消息：利用开源组件（cannal）伪装成 slave，获取 binlog 变更，转换为消息写到 MQ，让一个专门的消费者服务维护所有 key 的操作

## 缓存穿透

## 缓存击穿

## big key 优化

*   能避免就避免
*   不能避免就拆 key

## 热 key 优化

*   本地缓存
    * 容量小。机器内存除了运行需要，留给缓存的空间不多，存储的数据量不大。如果采用淘汰策略，可能数据之间互相挤压。
    * 怎么知道哪些是热门，哪些不是热门
    * 需更新所有进程
    * 对一致性要求不高，或者数据不更改

jdhotkeys 自动探测或手动设置；配置中心下发

点赞：重复点赞（lua脚本先判断是否重复后插入）

互联网业务基本都不用分布式事务，可能交易类业务会用

不用持久化，通过主备保证数据多份，异地

## 淘汰策略