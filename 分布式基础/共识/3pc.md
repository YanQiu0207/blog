# 三阶段提交

## 背景

2pc 主要有两个问题：

一是 TM 向存在网络故障或硬件故障的 RM 发送请求，超时后让所有 RM 回滚。

2pc 中，TM 不知道 RM 节点是否正常，只能通过超时来判断，此时会阻塞一段时间。另外，对于已经执行准备操作的 RM，回滚也是比较耗时的。

二是TM 向 RM 发送准备请求后发生故障，RM 无法继续提交或回滚事务，整个系统被阻塞。

2pc 中，TM 是有超时机制的。一是阶段 1 中，RM 有超时情况时，TM 按失败处理，给所有 RM 发送回滚指令；二是阶段 2 中，RM 有超时情况时，TM 需要对超时的 RM 持续重复发送指令。

那么 RM 为什么不能设置超时呢？因为进入阶段 2 后，RM 自己的任何操作都可能导致最终的不一致。如果 RM 因为网络故障导致超时回滚了，那么可能其它 RM 可能已经收到了 TM 的提交消息提交了本地事务。反之同理。

对此，3pc 的改进是：

- 增加第一阶段，提前询问 RM 是否能正常，避免 2pc 因为 RM 故障导致的无意义的超时等待和回滚。当然，RM 回复后立刻下线就没法避免了。
- RM 引入超时机制，避免 TM 故障后 RM 的资源无法释放，一直阻塞的问题。

## 缺点

3pc 为了解决 TM 故障时 RM 无法释放资源的问题引入了超时机制，但也会有数据不一致的情况。也就是说，3pc 是牺牲了线性一致性，换来了可用性。

实际上，2pc 也可以引入 RM 超时机制，此时两者就没有什么差别了。只不过，3pc 多了一个探测参与者是否正常的阶段（第一阶段），不一致的概率更低。所以，从这看起来 3pc 很鸡肋，这大概也就是它无人问津的原因吧。
