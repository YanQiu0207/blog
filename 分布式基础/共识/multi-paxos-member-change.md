## 成员变更

### 一阶段成员变更

关键点：如果能保证 C(old) 与 C(new) 的任意多数派必有交集，那么即可保证 C(old) 与 C(new) 无法各自形成多数派投票

方法：每次成员变更只允许增加或删除一个成员

假设 C(old) 的成员数为 N，分析如下：

*   C(new) 成员数为 N+1
    1. 假设选出的 leader 持有 C(new)，那么一定是 C(new) 中有多数派，即 (N+1)/2+1 的成员给 leader 投票。那么持有 C(old) 且未给 leader 投票的成员最多为 (N+1)-((N+1)/2+1)=(N-1)/2，这个值小于 C(old) 的多数派值 N/2+1，无法选出 leader
    1. 假设选出的 leader 持有 C(old)，那么一定是 C(old) 中有多数派，即 N/2+1 的成员给 leader 投票。那么持有 C(new) 且未给 leader 投票的成员最多为 (N+1)-(N/2+1)=N/2，这个值小于 C(new) 的多数派值 (N+1)/2+1，无法选出 leader
*   C(new) 成员数为 N-1
    1. 假设选出的 leader 持有 C(new)，那么一定是 C(new) 中有多数派，即 (N-1)/2+1 的成员给 leader 投票。那么持有 C(old) 且未给 leader 投票的成员最多为 N-((N-1)/2+1)=(N-1)/2，这个值小于 C(old) 的多数派值 N/2+1，无法选出 leader
    1. 假设选出的 leader 持有 C(old)，那么一定是 C(old) 中有多数派，即 N/2+1 的成员给 leader 投票。那么持有 C(new) 且未给 leader 投票的成员最多为 N-(N/2+1)=(N-1)/2，这个值小于 C(new) 的多数派值 (N-1)/2+1，无法选出 leader

启用新成员组的时机：从何时开始，对日志的投票开始使用 C(new) 进行。要考虑的问题是成员变更过程中宕机，重启选主后，持有 C(old) 的成员被选为 leader，在宕机前使用 C(new) 同步的日志是否可能丢失（不理解，为什么是这个问题？）

最大 commit 原则：

### 两阶段成员变更

待续。