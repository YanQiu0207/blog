#  Paxos

## 问题

问题：有一个变量 v，多个进程都尝试修改这个变量的值，有的进程想修改为 a，有的进程想修改为 b，但最终 v 会被确定为其中的某个值并且不会再变化。

对解决方法的要求：

- 安全性：
  - 只有被提议过的值才能被选定
  - **最多只能选定一个值**。即不能选定了一个值后又选定其他值
  - 除非一个值真的被选定，否则其它进程不会知道被选定的值是哪个
- 活性（集群中大多数服务器正常运行，并且相互之间可以及时通信）：
  - **最终总是能选定一个值**
  - 如果一个值被选定， 那么服务器最终会发现被选定的值是哪个

- fail-stop 故障模型：
  - 节点：服务器可能崩溃，或者可能会停止并重启
  - 异步网络模型：消息可能延迟、丢失、重复、乱序；甚至发生网络分区，但消息不会被篡改

平等性原则：进程之间是平等，不存在一个特殊的进程。如果有特殊进程，就必定存在单点问题。

消息是进程间通信的唯一手段。

角色：

- Proposer：
  - 主动：提出一些需要被选定的值
- Acceptor：
  - 被动：响应 Proposer 的消息
  - 响应可视为投票
  - 存储选定的值，投票过程的状态
  - 想知道哪个值被选定了

## Basic Paxos

### 可靠直观的解释

最简单的方法：只使用一个 Acceptor。所有的 Proposer 都将值发给某个 Acceptor，然后由它来从中选择一个值。虽然方法很简单，但如果 Acceptor 宕机，算法就无法继续下去，最终不能决定一个值或者无法得知被决定的值是哪个，不满足活性要求。**所以必须使用多个 Acceptor**。

使用多个 Acceptor，可能一个 Acceptor 接受的值是 v1，一个 Acceptor 接受的值是 v2，那么以谁的为准呢？**如果一个值 v 被多数派 Acceptor 接受了，那么它就被选定了**。通常使用奇数个 Acceptor，例如 3, 5, 7 等，如果使用偶数个 Acceptor，会存在一半赞同一半反对的情况。基于使用多个 Acceptor 的方式，即使有 Acceptor 宕机，只有还有多数派 Acceptor 存活，我们就能选定某个值并且能够知道选定的值是哪个。

Acceptor 如何接受值才会出现一个值被多数派 Acceptor 接受的情况呢？ 

如果 Acceptor 只接受它接收到的第一个值，可能造成分裂投票的情况。例如如果多个 Proposer 在同一时间提议了不同的值，就可能出现每个 Acceptor 都接受了一个值，但没有一个值被多数派 Acceptor 接受的情况。所以，**Acceptor 必须能够接受多个值**。

> 注意：接受一个值并不意味着选定了一个值，记住，只有被多数派 Acceptor 接受的值才是被选定的值。

如果 Acceptor 接受它所接收到的每一个值，可能会选定多个值的情况，即值 v1 被选定后，有选择了另一个值 v2，不符合算法的安全性要求。

为了避免选定多个值的情况出现，Proposer 在提议值的时候，可以先看看当前是否已经有值被选定了。如果是，那么就要放弃自己的值，改用被选定的值。这暗示了我们需要的是一个两阶段的协议。

但这样仍然不够，考虑多个 Proposer 同时提议值的情况，它们提议时系统中都没有值被选定，所以它们都可以提议自己的值，最终还是会有多个值被选定的情况。

目前来看，单靠 Proposer 是无法阻止多个值被选定的情况出现。所以，需要 Acceptor 能够拒绝掉提案，以维护算法的安全性。因此，我们需要给每个提案一个唯一的编号，让 Acceptor 能够区分不同的提案，并在某些情况下拒绝掉提案。

综上所述，我们需要的是一个两阶段的协议，Proposer 能够发现已选定的值，避免提议不同的值，Acceptor 能拒绝某些值，避免多次选定不同的值。

### 严格证明

在只有一个 Proposer 提议了一个值的情况下，我们希望也能够选定一个值，这暗示了：

> P1. 一个 Acceptor 必须接受它接收到的第一个提案

但这个要求带来了一个问题：如果多个 Proposer 在同一时间提议了不同的值，就可能出现每个 Acceptor 都接受了一个值，但没有一个值被多数派 Acceptor 接受的情况。

这也说明 Acceptor 不能只接受它接收的第一个提案，而是接受多个提案，否则会出现永远无法选定值得情况，即不满足活性要求。

为了区分不同的提案，我们要求每个提案必须要有一个唯一的编号。

当一个提案被多数派 Acceptor 接受后，我们就认为这个提案被选定了，即一个值被选定了。我们允许多个提案被选定，但我们必须保证这些被选定的提案必须有相同的值。

> P2. 如果一个值为 v 的提案被选定了，那么每个被选定的更大编号的提案，它们的值也是 v

由于提案的编号是全局有序的，所以 P2 保证了关键的安全性：只有一个值被选定。

为了被选定，一个提案必须被至少一个 Acceptor 接受。所以，我们可以通过满足下列条件来满足 P2，即如果 $P2^a$ 成立，那么 P2 一定成立

> $P2^a$. 如果一个值为 v 的提案被选定了，那么之后任意一个 Acceptor 接受的更大编号的提案的值一定是 v

但在某些情况下，P1 和 $P2^a$ 会有冲突。由于选定一个提案并不需要所有 Acceptor 都接受，所以，如果某个值被选定时，某个 Acceptor 正好宕机，就无法接受这个值了。等 Acceptor 重启后，有个 Proposer 发了一个更大编号的提案给这个 Acceptor，这个提案的值跟已选定的值不同。为了满足 P1，这个 Acceptor 必须接受这个提案，但同时也违反了 $P2^a$。因此，我们必须增强 $P2^a$，得到一个更强的假设。即如果这个假设成立，能推出 $P2^a$ 一定成立。

> $P2^b$. 如果一个值为 v 的提案被选定了，那么之后 Proposer 提出的任意一个有更大编号的提案的值一定是 v

由于一个提案必须先被 Proposer 提出，然后才能被 Acceptor 接受，所以 $P2^b$ 成立，推出 $P2^a$ 成立，推出 P2 成立。

> $P2^c$. 如果提出了一个编号为 n，值为 v 的提案，那么有一个由多数派 Acceptor 组成的集合 S，（a）集合 S 的 Acceptor 都没有接受过编号小于 n 的提案 (b) 所有 Acceptor 接受的提案中，编号比 n 小的最大提案的值一定是 v

如何证明满足 $P2^c$，就可满足 $P2^b$ 呢？

命题：如果一个提案 {m, v} 被多数派接受了，那么提议 m 到 n 对应的值都为 v，其中 n >= m

证明方法一：归纳法

对 n 进行归纳假设。

如果 n==m，结论显然成立

设 n==k,k>m 结论成立，那么 m 到 k 的提案值都为 v

下面要证明 n==k+1,k>m 时，m 到 k+1 的提案值都为 v. 基于 n==k 的假设，只需要证明提案 k+1 的值为 v 

假设提案 k+1 的值来自某个多数派集合所接受过的所有编号比 k+1 小的提案（记作Q）中编号最大的那个提案 t，记作 {t, v1}

由于两个多数派集合必有交集，所以这个多数派集合跟 {m, v} 成立时的多数派集合有交集，即提案集合 Q 必定包含 m

由于 t 是 Q 中编号最大的提案，所以 t >= m，根据选值策略，t < k+1，所以 m <= t < k+1

根据 n==k 的假设，v1=v。所以 n==k+1 时，m 到 k+1 的提案值都为 v

所以，对于任意编号不小于 m 的提案 n，对应的值都为 n

### 活锁问题

场景：理论上，两个提议者的 Prepare 和 Accept 阶段总是重叠，就会永远无法选定一个值的情况。

解决办法：

- 在开始下一次提议前，先随机延迟一段时间，给其他提议者一个完成 paxos 的机会
- 选择一个 leader，总是让它发起提案，避免多个提案冲突

### 其他问题

- 只有 Proposer 知道哪个值被选定了，连 Acceptor 也不知道自己接受的值是否被选定了。如果其他服务器想知道，必须运行一次 Paxos 协议。
- 一个变量的值被选定后就无法改变，对于一个可以多次改变值的变量，单靠 paxos 无法保证一致，必须结合状态机复制

## Multi Paxos

目标：创建一个复制的日志

为了实现 Multi Paxos，需要解决一下问题：

- 对于一个给定的客户端请求，应该使用哪个日志项
- 性能优化
  - 使用 leader 来减少提案冲突
  - 削减大多数 Prepare 请求：单个 RPC 处理完客户端请求
- 确保全复制：所有服务器最终都会获取每个日志项，并且每个服务器都知道每个日志项已经被选定
- 客户端协议
- 配置变更：向集群添加或删除新机器

### 选择日志项

当客户端的请求到来时，

- 找到第一个没有被选定的日志项
- 为这个日志项运行 Basic Paxos 算法，值为客户端命令
- Prepare 阶段是否返回已接受的值？
  - 是：这个日志项用这个已接受的值，然后从头再来
  - 否：用客户端命令作为这个日志项的值

- 服务器能够并发处理多个客户端请求
  - 每个客户端请求使用不同的日志项
- 必须以日志顺序应用命令到状态机

### 提升效率

Basic Paxos 低效的两个问题：

- 如果多个提案并发，冲突和重新开始的概率很大
- 每选定一个值都需要两轮 RPC，包括 Prepare 和 Accept

解决办法：

1. 选择一个 Leader
  - 在任意时间，只有一个服务器作为提议者
2. 减少大部分 Prepare RPC 调用
  - 一次 Prepare 覆盖整个日志，而不只是单个日志项
  - 许多日志项只需要一轮 RPC 就能够被选定

leader 选举：租约

- 需要 Prepare 阶段的两个原因：
  - 阻塞旧的提案：避免选定多个值，违背算法的安全性要求
    - 让提案编号关联整个日志，而不仅仅是单个日志项
  - 查找可能已选定的值：避免选定多个值，违背算法的安全性要求
    - 对当前日志项，仍然返回它所接受的最大编号的提案
    - 额外返回 noMoreAccepted：如果这个日志项之后的日志都没有接受过提案

- 如果 Acceptor 用 noMoreAccepted 响应 Prepare，那么这个 Acceptor 之后的 Prepare 都可以省略了。

- 一旦 Leader 接收到多数派 Acceptr 的 noMoreAccepted，那么就不需要 Prepare RPC 了。即对每个日志项，只需要 1 轮 RPC 就够了（直接 Accept）。


### 完全披露

信息流不完整：

- 日志项并没被完全复制到每个服务器上：因为只需要多数派 Acceptor 就能够选定一个值
- 只有 Proposer 知道哪个值被选定了，Acceptor 不知道这个信息

目的：每个服务器都有全部日志，并且知道哪些日志项被选定了

- 解决方法 1/4：在后台持续发送 Acceptor RPC 直到所有的 Acceptor 都响应
  - 完全复制了大多数日志项，但如果服务器宕机，有些日志就可能没有被完全复制。
- 解决方法 2/4：每个服务器都追踪被选定的日志项，需要做到以下两点
  - 标记被选定的日志项：acceptedProposal[i] = 无穷大
  - 每个服务器维护 firstUnchosenIndex：最早的未被选定的日志项的索引
- 解决方法 3/4：Proposer 告诉 Acceptor 哪些日志项被选定了

Acceptor 如何使用这个信息：它会将这个提案编号跟自己日志项已接受的提案编号进行比较，直到第一个未被选定的索引，如果它们有相等的提案编号，就将这个日志项设置为已选定。

为什么可以这么做？
提案编号相等，Acceptor 知道这个未被选定的日志项跟将要接受的日志项来自同个 Proposer，
这个索引对应的日志项在 Proposer 处已被选定

可以用反证法证明。

- 解决方法 4/4：Acceptor 不知道来自旧 leader 的日志项是否已经被选定了，可以通过询问 Proposer 来获知，如果 ProPoser's firstUnchosenIndex > Acceptor's firstUnchosenIndex

### 客户端如何与系统交互

- 将指令发送给领导者
  - 如果不知道谁是领导者，随机发送给集群中的一个节点
  - 如果该节点不是领导者，会将领导者告诉客户端，客户端重定向到真正的领导者
  - 如果该节点也不知道领导者，客户端询问集群中的其它机器
- 领导者选定了日志项并应用到状态机后，才给客户端响应。注意，必须先应用到状态机再给客户端返回，否则客户端下次可能读取到旧值
- 客户端会持续与领导者通信，直到请求超时（例如领导者宕机了）
  - 重新执行上述步骤
  - 可能存在重复执行某个客户端指令的情况，需要唯一递增ID去重
  - 只要客户端没有崩溃，指令会且仅会执行一次
  - 如果客户端崩溃，指令最多只执行一次

### 配置变更

关键点：配置决定了多数派

为什么需要变更？宕机或者需要更多机器来提高系统的可靠性

安全变更：变更期间，一定不能出现两个不同的多数派为同一个日志项选择了不同的值

解决办法：用日志来管理配置变更

## 使用场景

- 保证多机操作序列一致

