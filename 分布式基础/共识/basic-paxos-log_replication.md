## 基于 Basic-Paxos 协议的日志同步与恢复

传统的主备同步：同步复制、异步复制、半同步复制（优缺点参考DDIA）

基于 Paxos 协议的数据同步：只有集群中超过半数机器存活并且能正常通信，就能保证服务的持续可用，并且数据不会丢失。

场景：在 N 个 Server 组成的集群上，持久化数据库或文件系统的操作日志，并且为每条日志分配连续递增的日志ID。我们允许多个客户端并发地向集群内的任意机器发送日志同步请求。

运行一次 Basic-Paxos 算法只能持久化一条日志，我们把这个过程看作一个 Paxos Instance。有无穷多的日志需要持久化，每条日志需要一个 Paxos Instance。

（1）产生 LogID

含义：标识不同的 Paxos 实例。每个实例确定一个值。

方法：询问 Acceptor 本地目前已写盘的最大 LogID，只需要收集到大多数 Acceptor 返回的结果，之后从返回的 LogID 集合选择 MaxLogID+1 作为本次的 LogID

问题：不能保证并发提交的两条日志的 LogID 一定不同。但一个 Paxos 实例只能选定一个条日志。另一条日志需要重新选择 LogID

备注1：其实 LogID 从 1 开始都行，就是得不断提升 LogID，直到找到一个没人占用的 LogID。这种方法效率很低，所以我们采用询问大多数 Acceptor 的方式来获取 LogID，尽量避免了 LogID 冲突。同时，该方法也有一定的容错性，只需要大多数机器 Acceptor 存活就行。

（2）产生 ProposalID

含义：唯一标识一个提案。要求全局唯一和可比较

方法：server id(server ip) + timestamp + 自增ID

备注1：递增只是提高算法效率。就算不递增，对算法安全性没影响。
备注2：提案 ID 一定要唯一，即不能出现不同提案有相同提案ID的情况。

（3）回退
如果 P1b 阶段有返回提案
如果 P2b 阶段写入提案失败

遇到上述两种情况，需要重新选择 LogID，再跑一次 Paxos 算法

（4）读取日志

按 LogID 的顺序依次读取日志。对于每个 LogID，需要运行一次 paxos 来获取持久化的日志。

之前已经在大多数 Acceptor 上写入的日志一定能够被读出。如果没有，运行协议后，可能选中这条日志，也可能为空。

（5）日志的顺序问题

如果日志有顺序，只能由用户保证，得等上一条日志写入成功，才能写入下一条。

这种做法并发量很低，可以将多条日志合并为一次提交处理。

（6） Learner 如何得知哪个值被选定了

询问所有的 Acceptor，如果有一个值被大多数 Acceptor 返回，那么它就是被选定的那个值。

（7）客户端需要明确知道成功或者失败，如果遇到超时或其它异常，应该重试，直到结果确定。这里的关键是客户端必须知道 LogID。只凭 ProposalID 有可能出错，可能出现自己提交失败，别人帮你提交了。

（8）性能问题一：三次网络交互+两次写盘
三次网络交互
（1）产生 LogID
（2）Prepare 阶段
（3）Accept 阶段
两次写盘
（1）Acceptor 响应 prepare 消息
（1）Acceptor 响应 acceptor 消息

（9）性能问题二
高并发的情况下，多个不同提案分配到同个 LogID，重试次数多。

## 使用 Multi-Paxos 协议的日志同步与恢复机制
 
1. 通过 Paxos 选举 Leader 来避免每条日志都必须执行三阶段交互，大部分场景下都可以简化为一阶段交互。
2. 最大 commit 原则：对于日志的重确认，需要执行一轮完整的 Paxos 协议，因为无法区分它之前是否已形成多数派。
3. 引入 confirm 日志来简化回放处理，避免每条日志都执行一轮完整的 Paxos 协议
4. 引入 Start Working 日志和 GenerateID 来避免『幽灵复现』问题

## 参考资料

- [Paxos 三部曲之一 使用 Basic-Paxos 协议的日志同步与恢复](http://oceanbase.org.cn/?p=90)
- [Paxos 三部曲之二 使用 Multi-Paxos 协议的日志同步与恢复](http://oceanbase.org.cn/?p=111)
- [Paxos 三部曲之三 Paxos 成员组变更](http://oceanbase.org.cn/?p=160)

