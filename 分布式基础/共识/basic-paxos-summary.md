#  Basic Paxos

## 背景

问题：有一个变量 v，多个进程都尝试修改这个变量的值，有的进程想修改为 a，有的进程想修改为 b，但最终 v 会被确定为其中的某个值并且不会再变化

对解决方法的要求：

- 安全性
  - 只有被提议过的值才能被选定
  - **最多只能选定一个值**。即不能选定了一个值后又选定其他值
  - 除非一个值真的被选定，否则其它进程不会知道被选定的值是哪个

- 活性：只要集群中大多数服务器正常运行并且相互之间可以及时通信，那么
  - **最终总是能选定一个值**
  - 如果一个值被选定， 那么其它进程最终会发现被选定的值是哪个

- 能容忍的故障：fail-stop 故障模型
  - 节点：服务器可能崩溃或重启
  - 异步网络模型：消息可能延迟、丢失、重复、乱序；甚至发生网络分区，但消息不会被篡改

- 平等性原则：进程之间是平等，不存在一个特殊的进程。如果有特殊进程，就必定存在单点问题

- 消息是进程间通信的唯一手段

问题中的参与者可划分为两种角色：

- Proposer：
  - 主动：提出一些需要被选定的值
- Acceptor：
  - 被动：响应 Proposer 的消息，即投票
  - 存储选定的值、投票过程的状态

## 直观的解释

选定一个值最简单的方法：只使用一个 Acceptor。所有的 Proposer 都将值发给某个 Acceptor，然后由它来从中选择一个值。虽然方法很简单，但如果 Acceptor 宕机，算法就无法继续下去，最终不能决定一个值或者无法得知被决定的值是哪个，不满足活性要求。**所以必须使用多个 Acceptor**。

使用多个 Acceptor，可能一个 Acceptor 接受的值是 v1，一个 Acceptor 接受的值是 v2，那么以谁的为准呢？**如果一个值 v 被多数派 Acceptor 接受了，那么它就被选定了**。通常使用奇数个 Acceptor，例如 3, 5, 7 等，因为使用偶数个 Acceptor，会存在一半赞同一半反对的情况。基于使用多个 Acceptor 的方式，即使有 Acceptor 宕机，只有还有多数派 Acceptor 存活，我们就能选定某个值并且能够知道选定的值是哪个。

那么 Acceptor 如何接受值才会出现一个值被多数派 Acceptor 接受的情况呢？ 

如果 Acceptor 只接受它接收到的第一个值，可能造成分裂投票的情况。例如如果多个 Proposer 在同一时间提议了不同的值，就可能出现每个 Acceptor 都接受了一个值，但没有一个值被多数派 Acceptor 接受的情况，不满足活性要求。所以，**Acceptor 必须能够接受多个值**。

> 注意：Acceptor 接受一个值并不意味着这个值被选定了，记住，只有被多数派 Acceptor 接受的值才是被选定的值。

如果 Acceptor 接受它所接收到的每一个值，可能会选定多个值的情况，即值 v1 被选定后，有选择了另一个值 v2，不符合安全性要求。

为了避免选定多个值的情况出现，Proposer 在提议值的时候，可以先看看当前是否已经有值被选定了。如果是，那么就要放弃自己的值，改用被选定的值。这暗示了我们需要的是一个两阶段的协议；允许多个提案被大多数 Acceptor 接受，前提是这些提案的提议值必须是相同的。

但这样仍然不够，考虑多个 Proposer 同时提议值的情况，它们提议时系统中都没有值被选定，所以它们都可以提议自己的值，最终还是会有多个值被选定的情况，仍然不符合安全性要求。

目前来看，单靠 Proposer 是无法阻止多个值被选定的情况出现。所以，需要 Acceptor 能够拒绝掉提案，以维护算法的安全性。因此，我们需要给每个提案一个唯一的编号，让 Acceptor 能够区分不同的提案，并在某些情况下拒绝掉提案。

综上所述，我们需要的是一个两阶段的协议，Proposer 能够发现已选定的值，避免提议跟之前已选定值不同的值；Acceptor 能拒绝某些值，避免多个提案并发时多次选定不同的值。

上述两个问题如何解决?

如何发现那个已选定的值？如果之前已经选定了值，那么所有 Acceptor 接受的提案中，编号比 n 小的最大提案的值肯定是选定值。原理是两个多数派必有交集

如何避免多个提案并发时多次选定不同的值？每个提案一个唯一的编号，多个提案并发时，只有编号更大的提案才能在第二阶段写入，其它提案都要被拒绝

![20230414000603-2023-04-14](https://raw.githubusercontent.com/YanQiu0207/image/main/20230414000603-2023-04-14.png)

### 严格证明

在只有一个 Proposer 提议了一个值的情况下，我们希望也能够选定一个值，这暗示了：

> P1. 一个 Acceptor 必须接受它接收到的第一个提案

但这个要求带来了一个问题：如果多个 Proposer 在同一时间提议了不同的值，就可能出现每个 Acceptor 都接受了一个值，但没有一个值被多数派 Acceptor 接受的情况。

这也说明 Acceptor 不能只接受它接收的第一个提案，而是接受多个提案，否则会出现永远无法选定值得情况，即不满足活性要求。

为了区分不同的提案，我们要求每个提案必须要有一个唯一的编号。

当一个提案被多数派 Acceptor 接受后，我们就认为这个提案被选定了，即一个值被选定了。我们允许多个提案被选定，但我们必须保证这些被选定的提案必须有相同的值。

> P2. 如果一个值为 v 的提案被选定了，那么每个被选定的更大编号的提案，它们的值也是 v

由于提案的编号是全局有序的，所以 P2 保证了关键的安全性：只有一个值被选定。

为了被选定，一个提案必须被至少一个 Acceptor 接受。所以，我们可以通过满足下列条件来满足 P2，即如果 $P2^a$ 成立，那么 P2 一定成立

> $P2^a$. 如果一个值为 v 的提案被选定了，那么之后任意一个 Acceptor 接受的更大编号的提案的值一定是 v

但在某些情况下，P1 和 $P2^a$ 会有冲突。由于选定一个提案并不需要所有 Acceptor 都接受，所以，如果某个值被选定时，某个 Acceptor 正好宕机，就无法接受这个值了。等 Acceptor 重启后，有个 Proposer 发了一个更大编号的提案给这个 Acceptor，这个提案的值跟已选定的值不同。为了满足 P1，这个 Acceptor 必须接受这个提案，但同时也违反了 $P2^a$。因此，我们必须增强 $P2^a$，得到一个更强的假设。即如果这个假设成立，能推出 $P2^a$ 一定成立。

> $P2^b$. 如果一个值为 v 的提案被选定了，那么之后 Proposer 提出的任意一个有更大编号的提案的值一定是 v

由于一个提案必须先被 Proposer 提出，然后才能被 Acceptor 接受，所以 $P2^b$ 成立，推出 $P2^a$ 成立，推出 P2 成立。

> $P2^c$. 如果提出了一个编号为 n，值为 v 的提案，那么有一个由多数派 Acceptor 组成的集合 S，（a）集合 S 的 Acceptor 都没有接受过编号小于 n 的提案 (b) 所有 Acceptor 接受的提案中，编号比 n 小的最大提案的值一定是 v

如何证明满足 $P2^c$，就可满足 $P2^b$ 呢？

命题：如果一个提案 {m, v} 被多数派接受了，那么提议 m 到 n 对应的值都为 v，其中 n > m

证明方法一：归纳法

对 n 进行归纳假设。

如果 n == m+1，结论显然成立

假设 n == k,k>m 结论成立，那么 m 到 k 的提案值都为 v

下面要证明 n == k+1,k>m 时，m 到 k+1 的提案值都为 v. 由于 n == k 的假设成立，只需要证明提案 k+1 的值为 v 

假设提案 k+1 的值来自某个多数派集合所接受过的所有编号比 k+1 小的提案（记作Q）中编号最大的那个提案 t，记作 {t, v1}

由于两个多数派集合必有交集，所以这个多数派集合跟 {m, v} 成立时的多数派集合有交集，即提案集合 Q 必定包含 m

由于 t 是 Q 中编号最大的提案，所以 t >= m，根据选值策略，t < k+1，所以 m <= t < k+1

根据 n==k 的假设，提案 t 的提议值 v1=v

所以 n==k+1 时，m 到 k+1 的提案值都为 v

因此，对于任意编号不小于 m 的提案 n，对应的值都为 n

证明方法二：反证法

需要证明以下命题存在矛盾：如果一个提案 {m, v} 被多数派接受了，存在一个提案 {n, v1}，n > m，但 v != v1

假设 n 是编号大于 m 的最小提案，即 n == m+1

一定是提案 {m, v} 先被多数派接受了，然后才提出提案 {n, v1}，否则提案 {m, v} 一定无法被接受，因为提案编号 m < n

接受提案 {m, v} 的多数派集合为 S1；提案 {n, v1} 能被提出，说明有一个多数派集合 S2 响应了 Prepare 请求；

这两个多数派集合 S1 和 S2 必有交集，也就是说存在一个进程，先接受了提案 {m, v}，后响应了提案 {n, v1} 的 Prepare 请求

记多数派集合 S2 所接受过的所有编号比 n 小的提案为 Q，由于两个多数派集合 S1 和 S2 必有交集，所以提案集合 Q 必定包含提案 m

提案集合 Q 中编号最大的那个提案为 t，那么 m <= t。提案 t 的提议值为 v1，由于 v != v1，所以 t != m。即 m < t

由于 t < n，所以 m < t < n，但 m 和 n 之间不可能存在其他提案，所以 t 不存在

## 常见问题

1. 提案编号的要求：唯一就行？
2. prepare b 可以等于 pb 吗？
3. accept b > pb ?

## 参考文章

- [如何浅显易懂地解说 Paxos 的算法？](https://www.zhihu.com/question/19787937)
- [微信 PaxosStore：深入浅出 Paxos 算法协议](https://mp.weixin.qq.com/s/aJoXSQo9-zmukN2RsiZ3_g)
- [朴素 Paxos 算法理论推导与证明](https://mp.weixin.qq.com/s/eeJXS5rBA9mXpSJaTNjF-Q)
- [从 Paxos 到 Multi-Paxos (一)](https://zhuanlan.zhihu.com/p/432800857)
- [从 Paxos 到 Multi-Paxos（二）](https://zhuanlan.zhihu.com/p/477462091)
