## 背景

问题：有一个变量 v，多个进程都尝试修改这个变量的值，有的进程想修改为 a，有的进程想修改为 b，但最终 v 会被确定为其中的某个值并且不会再变化

> 注意：这里并不要求每个进程的值都一样，只要求客户端访问任意进程都能读取到相同的值，后者具有更高的可用性

对解决方法的要求：

- 安全性
  - 只有被提议过的值才能被选定
  - **最多只能选定一个值**。即不能同时选定两个值，也不能选定了一个值后又选定其他值
  - 一个值只有被选定后，才能被客户端获取

- 活性：只要集群中大多数服务器正常运行并且相互之间可以及时通信，那么
  - **最终总是能选定一个值**

- 故障模型：fail-stop
  - 发生故障时，节点会停止响应，但不会执行任何其他不正确的行为，例如伪造消息
  - 其他的节点能可靠地检测到一个节点已经停止工作（即加上了同步网络的假设）

- 平等性原则：进程之间是平等，不存在一个特殊的进程。如果有特殊进程，就必定存在单点问题

- 消息是进程间通信的唯一手段

问题中的参与者可划分为两种角色：

- Proposer：
  - 主动：提出一些需要被选定的值
- Acceptor：
  - 被动：响应 Proposer 的消息，即投票
  - 存储选定的值、投票过程的状态

## 直观的解释

选定一个值最简单的方法：只使用一个 Acceptor。所有的 Proposer 都将值发给某个 Acceptor，然后由它来从中选择一个值。虽然方法很简单，但如果 Acceptor 宕机，算法就无法继续下去，最终不能决定一个值或者无法得知被决定的值是哪个，不满足活性要求。**所以必须使用多个 Acceptor**。

使用多个 Acceptor，可能一个 Acceptor 接受的值是 v1，一个 Acceptor 接受的值是 v2，那么以谁的为准呢？**如果一个值 v 被多数派 Acceptor 接受了，那么它就被选定了**。通常使用奇数个 Acceptor，例如 3, 5, 7 等，因为使用偶数个 Acceptor，会存在一半赞同一半反对的情况。基于使用多个 Acceptor 的方式，即使有 Acceptor 宕机，只有还有多数派 Acceptor 存活，我们就能选定某个值并且能够知道选定的值是哪个。

那么 Acceptor 如何接受值才会出现一个值被多数派 Acceptor 接受的情况呢？ 

如果 Acceptor 只接受它接收到的第一个值，可能造成分裂投票的情况。例如如果多个 Proposer 在同一时间提议了不同的值，就可能出现每个 Acceptor 都接受了一个值，但没有一个值被多数派 Acceptor 接受的情况，不满足活性要求。所以，**Acceptor 必须能够接受多个值**。

> 注意：Acceptor 接受一个值并不意味着这个值被选定了，记住，只有被多数派 Acceptor 接受的值才是被选定的值。

如果 Acceptor 接受它所接收到的每一个值，可能会选定多个值的情况，即值 v1 被选定后，有选择了另一个值 v2，不符合安全性要求。

为了避免选定多个值的情况出现，Proposer 在提议值的时候，可以先看看当前是否已经有值被选定了。如果是，那么就要放弃自己的值，改用被选定的值。这暗示了我们需要的是一个两阶段的协议；允许多个提案被大多数 Acceptor 接受，前提是这些提案的提议值必须是相同的。

但这样仍然不够，考虑多个 Proposer 同时提议值的情况，它们提议时系统中都没有值被选定，所以它们都可以提议自己的值，最终还是会有多个值被选定的情况，仍然不符合安全性要求。

目前来看，单靠 Proposer 是无法阻止多个值被选定的情况出现。所以，需要 Acceptor 能够拒绝掉提案，以维护算法的安全性。因此，我们需要给每个提案一个唯一的编号，让 Acceptor 能够区分不同的提案，并在某些情况下拒绝掉提案。

综上所述，我们需要的是一个两阶段的协议，Proposer 能够发现已选定的值，避免提议跟之前已选定值不同的值；Acceptor 能拒绝某些值，避免多个提案并发时多次选定不同的值。

上述两个问题如何解决?

如何发现那个已选定的值？如果之前已经选定了值，那么所有 Acceptor 接受的提案中，编号比 n 小的最大提案的值肯定是选定值。原理是两个多数派必有交集

如何避免多个提案并发时多次选定不同的值？每个提案一个唯一的编号，多个提案并发时，只有编号更大的提案才能在第二阶段写入，其它提案都要被拒绝

## 严格证明

在只有一个 Proposer 提议了一个值的情况下，我们希望也能够选定一个值，这暗示了：

> P1. 一个 Acceptor 必须接受它接收到的第一个提案

但这个要求带来了一个问题：如果多个 Proposer 在同一时间提议了不同的值，就可能出现每个 Acceptor 都接受了一个值，但没有一个值被多数派 Acceptor 接受的情况。

这也说明 Acceptor 不能只接受它接收的第一个提案，而是接受多个提案，否则会出现永远无法选定值得情况，即不满足活性要求。

为了区分不同的提案，我们要求每个提案必须要有一个唯一的编号。

当一个提案被多数派 Acceptor 接受后，我们就认为这个提案被选定了，即一个值被选定了。我们允许多个提案被选定，但我们必须保证这些被选定的提案必须有相同的值。

> P2. 如果一个值为 v 的提案被选定了，那么每个被选定的更大编号的提案，它们的值也是 v

由于提案的编号是全局有序的，所以 P2 保证了关键的安全性：只有一个值被选定。

为了被选定，一个提案必须被至少一个 Acceptor 接受。所以，我们可以通过满足下列条件来满足 P2，即如果 $P2^a$ 成立，那么 P2 一定成立

> $P2^a$. 如果一个值为 v 的提案被选定了，那么之后任意一个 Acceptor 接受的更大编号的提案的值一定是 v

但在某些情况下，P1 和 $P2^a$ 会有冲突。由于选定一个提案并不需要所有 Acceptor 都接受，所以，如果某个值被选定时，某个 Acceptor 正好宕机，就无法接受这个值了。等 Acceptor 重启后，有个 Proposer 发了一个更大编号的提案给这个 Acceptor，这个提案的值跟已选定的值不同。为了满足 P1，这个 Acceptor 必须接受这个提案，但同时也违反了 $P2^a$。因此，我们必须增强 $P2^a$，得到一个更强的假设。即如果这个假设成立，能推出 $P2^a$ 一定成立。

> $P2^b$. 如果一个值为 v 的提案被选定了，那么之后 Proposer 提出的任意一个有更大编号的提案的值一定是 v

由于一个提案必须先被 Proposer 提出，然后才能被 Acceptor 接受，所以 $P2^b$ 成立，推出 $P2^a$ 成立，推出 P2 成立。

> $P2^c$. 如果提出了一个编号为 n，值为 v 的提案，那么有一个由多数派 Acceptor 组成的集合 S 满足以下两个条件之一，（a）集合 S 的 Acceptor 都没有接受过编号小于 n 的提案 (b) 所有 Acceptor 接受的提案中，编号比 n 小的最大提案的值一定是 v

如何证明满足 $P2^c$，就可满足 $P2^b$ 呢？

命题：如果一个提案 {m, v} 被多数派接受了，那么提议 m 到 n 对应的值都为 v，其中 n > m

证明方法一：归纳法

对 n 进行归纳假设。

如果 n == m+1，结论显然成立

假设 n == k,k>m 结论成立，那么 m 到 k 的提案值都为 v

下面要证明 n == k+1,k>m 时，m 到 k+1 的提案值都为 v. 由于 n == k 的假设成立，只需要证明提案 k+1 的值为 v 

假设提案 k+1 的值来自某个多数派集合所接受过的所有编号比 k+1 小的提案（记作Q）中编号最大的那个提案 t，记作 {t, v1}

由于两个多数派集合必有交集，所以这个多数派集合跟 {m, v} 成立时的多数派集合有交集，即提案集合 Q 必定包含 m

由于 t 是 Q 中编号最大的提案，所以 t >= m，根据选值策略，t < k+1，所以 m <= t < k+1

根据 n==k 的假设，提案 t 的提议值 v1=v

所以 n==k+1 时，m 到 k+1 的提案值都为 v

因此，对于任意编号不小于 m 的提案 n，对应的值都为 v

证明方法二：反证法

需要证明以下命题存在矛盾：如果一个提案 {m, v} 被多数派接受了，存在一个提案 {n, v1}，n > m，但 v != v1

假设 n 是编号大于 m 的最小提案，即 n == m+1

一定是提案 {m, v} 先被多数派接受了，然后才提出提案 {n, v1}，否则提案 {m, v} 一定无法被接受，因为提案编号 m < n

接受提案 {m, v} 的多数派集合为 S1；提案 {n, v1} 能被提出，说明有一个多数派集合 S2 响应了 Prepare 请求；

这两个多数派集合 S1 和 S2 必有交集，也就是说存在一个进程，先接受了提案 {m, v}，后响应了提案 {n, v1} 的 Prepare 请求

记多数派集合 S2 所接受过的所有编号比 n 小的提案为 Q，由于两个多数派集合 S1 和 S2 必有交集，所以提案集合 Q 必定包含提案 m

提案集合 Q 中编号最大的那个提案为 t，那么 m <= t。提案 t 的提议值为 v1，由于 v != v1，所以 t != m。即 m < t

由于 t < n，所以 m < t < n，但 m 和 n 之间不可能存在其他提案，所以 t 不存在

## 算法过程

图片来自[这里](https://mp.weixin.qq.com/s/eeJXS5rBA9mXpSJaTNjF-Q)
![20230414000603-2023-04-14](https://raw.githubusercontent.com/YanQiu0207/image/main/20230414000603-2023-04-14.png)

## 常见问题

1. paxos 的第一阶段的目的是什么？
答：第一阶段尝试获取已选定值和获得写入权，它保证了算法的安全性，避免选定值后又选定一个新值。

2. paxos 只用第二阶段能达成目的吗？
答：不行，会多次选定值，违反安全性要求。

3. 提案编号 b 需要全局递增吗？即一个提案编号 b1 出现后，后面的提案编号 b2 一定要大于 b1 吗？
答：paxos 中对提案编号 b 的要求是全局唯一且可以比较大小，并不强求一定要全局递增。以上述为例，如果 b2 < b1，那么这个提案就会被拒绝，此时 proposer 需要提升 b2 再重试，直到大于 b1。也就是说，提案编号不递增只影响算法的性能，不影响算法的安全性。

生成提案编号的方法：

- 提供一个生成提案编号的服务，所有 proposer 在发起提案前，向该服务申请一个全局唯一、全局递增的编号。但该方案的问题是不能确保服务的可靠性
- 为每个 proposer 设定一个编号 I (I >= 0)，在生成提案编号时，使用公式 $N * J + I$ (N 为 proposer 的个数，J 为 proposer 本地记录的提案顺序号)
- 使用 时间戳+节点编号+自增ID 的方式

4. 在 OnPrepare 中，满足 b >= pb 就响应成功。如果多个提案的 b 相同，v 不同，不就出现了多次选定不同值，违背算法的安全性要求的情况？
答：如果能保证提案编号 b 是唯一的，例如时间戳+服务器id+自增ID，那么 b >= pb 就没问题。如果不能保证，就必须改成 b > pb

> 用 > 号会带来什么问题？在工程实现中，> 号带来的问题是，每次重试都需要提升ballot，不管是什么原因导致的重试。multi-paxos 优化带来了一个问题， ballot 是全局增长的，不会因为 instance 的增长而清零。
> 那这两点加起来会引发什么现象呢？当少数派机器无法和多数派机器取得联系的时候（比如网络分区），那么这些机器会在重试的过程中不断的提升 ballot， 而当这些机器重新和其他机器恢复联系的时候，由于这个 ballot 是全局最大的，必然会打破 multi-paxos 的 Leader 状态，导致需要重新执行 prepare。而这个现象在网络异常，拥堵，丢包，机器过载等紧急状态，会进一步加剧系统的崩溃，这在工程上是不能接受的。
> 那么解决的方法必然就是避免重试的时候提升 ballot.
> 可以看到 phxpaxos 里面在 prepare 阶段是先执行本地逻辑的， 在 accept 阶段本地则是最后才执行，很明显的有意为之来解决这个问题。
> 而带来的性能问题其实影响并不大，在大并发的时候不会过多的影响整体吞吐，况且，大多数情况下， multi-paxos 的优化，使得 prepare 阶段是不需要执行的。
> Raft社区采用的PreVote应该也可以解决。

5. 在 OnPrepare_Response 中，为什么选择编号最大的提案的值？
答：编号最大的提案的值并不一定是已经得到多数派 acceptor 的成功回复的值。只是这样做能保证：如果之前已经有值被选定了，那么此次选择的一定是那个被选定的值，保证了算法的安全性。

6. 为什么 Acceptor 要承诺不接受 b < pb 的提案呢？
答：为了保证某轮 paxos 第二阶段的提案值不受未来变化的影响（与其预测未来，不如限制未来）。举个例子，去掉 b < pb 的限制，假设当前提案编号是 5，prepare 阶段大多数 Acceptor 返回的最大提案编号是 3，proposer 选择了提案 3 对应的提议值作为自己的提议值。下一刻，大多数 Acceptor 接受了提案编号 4 的提案。再下一刻，proposer 发出了 accept 请求，大多数 Acceptor 接受了提案编号 3 的提案。由于多次选定不同的值，违背了算法的安全性。如果加上承诺不接受 b < pb 的提案，那么**下一刻，大多数 Acceptor 接受了提案编号 4 的提案**这里其实是无法实现的，也就保证了算法的安全性。

7. 一旦出现一次成功的投票，直接整个系统停止并拒绝之后一切协议不就完了吗，为什么要让后续投票保持和前面投票结果一致呢？
答：出现成功投票到整个系统停止之间，肯定存在一个时间差，还可以发起投票。也就是说，多轮投票是不可避免的，而为了保证算法的正确性，就必须让多轮投票的结果一样。另外，读取也需要进行一次 paxos 流程，否则无法获取选定值

8. 为什么机器数量都要求多数派？
答：两个多数派必有交集，保证两点：

- 一是只有一个提案能达成共识
- 二是达成共识的提案在不同轮次间传递

事实上，只要保证 R + W > N 就能保证算法的正确性，而 R 和 W 可以根据实际情况调整

9. 问题：第二阶段的 Acceptor 集合需要和 第一阶段的 Acceptor 集合完全一致吗？

不需要完全一致，但需要做到两点：

- 一是两个集合必须要有交集，否则会出现多个提案达成共识的情况，例子见上述第 6 点
- 二是第二阶段 Acceptor 的实现需改为：

```python
OnAccept(b,v):
  if b >= pb:
    pb=b,ab=b,av=v, Accept_Response(ok)
  else Accept_Response(reject)
```

这里的优化针对的情况：有些 Acceptor 没收到第一阶段的 prepare 请求，直接收到了第二阶段的 Accept 请求。所以，优化后的实现相当于让这种 Acceptor 先执行了 OnPrepare，再执行 OnAccept。如果 OnAccept 成功，那么 OnPrepare 是必定成功的。这种优化并没有违背算法的流程。

10. 活锁是指多个 proposer 同时发起提案，每个提案的 prepare 请求和 accept 请求交互运行，互相干扰，导致算法一直无法选定一个值

解决办法：

- 设置最小重试间隔+随机值。在这个时间内，其它 proposer 能正常完成算法流程。同时，避免同时超时导致又一次冲突。
- 在 Multi-Paxos 中，leader 才有资格发起提案，通过减少发起提案成员的数量来降低提案发生冲突的概率 

## 参考文章

- [如何浅显易懂地解说 Paxos 的算法？](https://www.zhihu.com/question/19787937)
- [微信 PaxosStore：深入浅出 Paxos 算法协议](https://mp.weixin.qq.com/s/aJoXSQo9-zmukN2RsiZ3_g)
- [朴素 Paxos 算法理论推导与证明](https://mp.weixin.qq.com/s/eeJXS5rBA9mXpSJaTNjF-Q)
- [从 Paxos 到 Multi-Paxos (一)](https://zhuanlan.zhihu.com/p/432800857)
- [从 Paxos 到 Multi-Paxos（二）](https://zhuanlan.zhihu.com/p/477462091)

## 相关实现

- [如何实现一个 Paxos](https://zhuanlan.zhihu.com/p/490329189)

## 其它问题

适用场景：数据复制。为什么不用主从复制？它有什么缺点？用了 paxos 就没有这些问题了吗？

paxos 和 二阶段提交有什么区别？

一致跟共识的区别

多数派和 quorum

日志空洞，最大 commit 原则

Multi-Paxos 优化方向：减少 rpc 交互次数和存盘次数

如何向 Learner 同步日志