# 共识总结

## 闲聊

无论使用何种一致性协议, 一定存在某个时间点, 多个副本不一致. 这是无法解决的。要解决的是读一致性, 即从观察者(用户)的角度看, 数据是一致的。写操作永远都是"最终一致"的

Basic-Paxos 不区分读写操作，读就是写，就是在做数据同步。Basic-Paxos 不知道哪个值已达成共识，所以想读取数据就只能走一遍流程，成功则返回达成共识的值。如果之前未达成共识，那么读操作会把某个值复制到大多数节点，所以 Basic-Paxos 是读修复。这种读修复不会主动进行，需要外界的请求触发

Basic-Paxos 不是所谓的多数派读写（W + R > N）。多数派读写不能保证线性一致性[^1]，有以下问题：

* 写入多数派节点不是瞬间完成的，而是有一个过程。写入过程中，可能先从已写入节点读到新值，又从未写入节点读到旧值，不符合线性一致性

* 写入多数派节点失败，可能从已写入节点读到新值，也可能从未写入节点读到旧值，不符合线性一致性

* 并发写入操作没有明确的先后顺序

* 存有新值的节点宕机，从存有旧值的节点恢复数据，会导致多数派关系变化

## 常见优化

### PreVote

（1）问题

（2）解决办法

### 读优化

#### LogRead

（1）流程

对于每个读取请求，leader 也生成一条日志并复制给其他 follower，然后将其 commit。当已 commit 的日志 apply 到状态机后，leader 返回结果给客户端

（2）原理

Log 是严格全序（total order）的，那么所有 R/W 都是全序的，将这些 R/W 操作一个个应用到状态机，所得的结果必定符合线性一致性

（3）优点

能实现线性一致性

（4）缺点

性能低，包括网络 IO，磁盘 IO 和磁盘存储成功（读多写少）

#### ReadIndex

（1）流程

1. 记录当前的 commit index，称为 ReadIndex
2. 确定现在仍是 leader：向所有节点发起一次心跳，如果大多数节点回复了，那就是 leader。这样做是因为 leader 才有最新状态
3. 等待状态机**至少**应用到 ReadIndex 的 Log。**至少**表明状态机应用到 ReadIndex 之后的状态都能使这个请求满足线性一致性，不管过了多久，不管 leader 有没有飘走
4. 执行读请求，将结果返回给客户端

（2）原理

Read-Wait 策略：在读操作执行期间增加等待时间或同步机制，以保证读取的数据反映所有先前的写入，从而维持线性一致性

（3）优点

相比 LogRead，节省了磁盘 IO，能大幅提升读的吞吐，减小延时

（4）缺点
读取操作的延时仍然比较高，主要是还有确认 leader 这个网络 IO

#### LeaseRead

（1）流程

leader 取一个比 Election Timeout 小的租期，在租期内不会发生选举，确保 leader 不会变，所以可以跳过 ReadIndex 的第二步，也就降低了延时

1. 记录当前的 commit index，称为 ReadIndex
2. 还在租期内，leader 可以直接读，否则还是需要确认 leader
3. 等待状态机**至少**应用到 ReadIndex 的 Log。**至少**表明状态机应用到 ReadIndex 之后的状态都能使这个请求满足线性一致性，不管过了多久，不管 leader 有没有飘走
4. 执行读请求，将结果返回给客户端

（2）原理

租约机制

（3）优点

省去了网络 IO 和磁盘 IO，可以大幅提升读的吞吐，也能显著降低延时

（4）缺点

正确性和时间挂钩，如果不同节点间时间漂移严重，这个机制就会有问题

#### Wait-Free

（1）流程

还在租期内，leader 可以直接读状态机，不需要去 commit index 也不等状态机

（2）原理

由于 Raft 的强 leader 特性，在 Lease 内客户端收到的响应都由 leader 的状态机产生，所以只要状态机满足线性一致性，那么在 Lease 内，不管何时发生读都能满足线性一致性

但有一点要注意，只有在 leader 的状态机应用了当前 term 第一个 log 后才能进行 LeaseRead。因为新选举产生的 Leader，虽然有全部的 commited log，但它的状态机可能落后于之前的 Leader，状态机应用了当前 term 的 log 后就保证了新 leader 的状态一定新于旧 leader，之后就肯定不会出现 stale read

（3）优点

性能非常高

（4）缺点

正确性和时间挂钩，如果不同节点间时间漂移严重，这个机制就会有问题

https://www.ideawu.net/blog/archives/1192.html

#### 其它问题

* Leader 的状态机在什么时候没有最新状态？要线性一致性，Raft 该如何解决这问题？
* FollowerRead 可以由 ReadIndex 实现，那么能由 LeaseRead 实现吗？

### 幽灵复现

#### 问题

使用Paxos协议处理日志的备份与恢复，可以保证确认形成多数派的日志不丢失，但是无法避免一种被称为“幽灵复现”的现象，如下图所示：

https://www.ideawu.net/blog/archives/1187.html

* [线性一致性和 Raft](https://cn.pingcap.com/blog/linearizability-and-raft/)
* [线性一致读实现剖析](https://www.sofastack.tech/blog/sofa-jraft-linear-consistent-read-implementation/)

### 高可用

https://www.ideawu.net/blog/archives/1183.html

### 提交前任的日志

https://www.ideawu.net/blog/archives/1164.html

[^1]: 简单来说，如果一个系统总是返回最新写入的值，那么它就是线性一致的。可以从两个方面来判断一个系统是否满足线性一致性，一是写入完成后的任意读操作一定能读到写入的值；二是写入过程中，如果一个客户端已看到最新值，之后的任意读操作一定也能读到这个值

[^2]: 全序广播的特性，一是全局顺序，保证所有参与节点都以完全相同的顺序接收消息；二是可靠性，所有发送的消息最终都会被所有正常运行的节点接收

## 其它

阿里云的多写
阿里云的线性一致性
陈宗志的 pipeline 和 batch
