# 分布式锁

## 目的

对共享资源进行互斥访问，以达到以下目的：

* **效率**：避免多个客户端做重复的工作，即使锁偶尔失效了，也只是把某些操作多做了一遍而已，不会产生其它不良后果。使用单 Redis 节点的锁方案就足够了，简单且效率高
* **正确性**：在任何情况下都不允许锁失效，因为一旦发生，可能导致数据不一致，数据丢失，文件损坏等。此时考虑 Zookper 方案或支持事务的数据库

实际上，分布式锁没法做到完全正确，即使是 Zookper 方案 + 单调递增的 epoch number + 分布式资源进行标记，也有非常小的概率导致互斥语义失效。一般来说，一个分布式锁服务，正确性要求越高，性能就越低

## 特性

（1）功能
* 互斥：同一个时刻，只能有一个客户端访问共享资源
* 完备的锁接口：阻塞的和非阻塞的接口都要有，lock 和 tryLock
* 公平性：获取锁失败时，可能不立刻返回失败而是等待解锁。锁唤醒时，按先进先出（FIFO）的顺序
* 可重入性：允许同个客户端多次获取锁，需要保证客户端标识的唯一性
* 避免死锁：持有锁的客户端因各种原因释放锁失败，锁也有机会被清除，否则其它客户端无法继续获取锁，服务中断。通常采用超时机制来解决。

（2）技术
* 可用性：锁服务是否存在单点故障？

## 基于单 Redis 节点的分布式锁

1.实现要点：

（1）**锁必须设置过期时间**，否则一个客户端获取锁后，可能因为程序 bug，节点宕机，网络故障等导致锁没有释放，其他客户端也永远无法获取锁
（2）**加锁和设置锁的超时时间必须是一个原子操作**，否则一个客户端获取锁后崩溃，未设置到超时时间，导致它一直持有这个锁
（3）**加锁必须设置锁的所有者**（唯一标识一个客户端），保证一个客户端只能释放自己持有的那个锁。例如，客户端 A 持有锁超时了，客户端 B 获取了锁，此时客户端 A 去解锁，如果解锁成功的话，客户端 B 的锁就没有保护了
（4）**删除锁也必须是原子的**，否则可能释放其它客户端的锁，跟（3）类似

2.问题点：

（1）锁的有效期如何设置

* 如果设置太短，可能客户端还没访问完共享资源锁就超时了，其它客户端可能获取到锁，此时会有两个客户端同时访问共享资源，导致共享资源失去保护

* 如果设置太长，持有锁的客户端释放锁失败，其它客户端无法获取锁，导致服务长时间中断

（2）客户端拿到锁时，如果锁的有效期很短，还来得及访问共享资源吗？如果太短，是否应该立刻释放？那多短算短呢？

（3）如果客户端拿到锁后，因进程卡顿或网络超时导致锁过期，共享资源可能就失去保护了

（4）主从 Redis 的 failover 可能会破坏锁的安全性，因为主从之间是异步复制

## Redlock 算法

1.目的：解决基于主从 Redis 的分布锁在  failover 时可能会破坏锁的安全性的问题

2.算法：基于 N 个完全独立的 Redis 节点，依次向所有节点发送加锁请求，只要收到大多数节点的成功响应且没有超过锁的有效期，就算加锁成功

3.实现要点：

（1）如果获取锁的耗时超过锁的有效期，即使收到大多数节点的成功响应，也算加锁失败，需要向所有节点发起解锁请求

（2）解锁时，客户端应该向所有 Redis 节点发起释放锁的操作，不管这些是否获取锁成功

4.注意

（1）每个 Redis 节点都是非主从结构，否则也会有 failover 失去锁安全性的问题

（2）节点崩溃后立刻重启可能影响锁的安全性，跟数据的持久化机制有关，考虑延时重启，等节点上的所有锁过期

5.问题点，跟单 Redis 节点实现的分布式锁类似

（1）锁的有效期如何设置

* 如果设置太短，可能客户端还没访问完共享资源锁就超时了，其它客户端可能获取到锁，此时会有两个客户端同时访问共享资源，导致共享资源失去保护

* 如果设置太长，持有锁的客户端释放锁失败，其它客户端无法获取锁，导致服务长时间中断

（2）客户端拿到锁时，如果锁的有效期很短，还来得及访问共享资源吗？如果太短，是否应该立刻释放？那多短算短呢？

（3）如果客户端拿到锁后，因进程卡顿或网络超时导致锁过期，共享资源可能就失去保护了

## fencing token

带自动过期的分布式锁，因进程卡顿或网络超时，仍然会造成两个客户端同时访问共享资源的情况发生，此时需要共享资源参与进来，基于 fencing token 提供安全性

### 算法流程

* 当客户端成功获取锁时，给客户端返回一个 token，它是一个单调递增的数字
* 客户端访问共享资源时，带着这个 token
* 共享资源根据这个 token 进行检查，拒绝掉延迟到来的访问请求，从而避免冲突

### 难点

* Martin提出的fencing token的方案，需要对提供共享资源的服务进行修改，这在现实中可行吗？

* 根据Martin的说法，看起来，如果资源服务器实现了fencing token，它在分布式锁失效的情况下也仍然能保持资源的互斥访问。这是不是意味着分布式锁根本没有存在的意义了？

* 资源服务器需要检查fencing token的大小，如果提供资源访问的服务也是包含多个节点的（分布式的），那么这里怎么检查才能保证fencing token在多个节点上是递增的呢？

* Martin对于fencing token的举例中，两个fencing token到达资源服务器的顺序颠倒了（小的fencing token后到了），这时资源服务器检查出了这一问题。如果客户端1和客户端2都发生了GC pause，两个fencing token都延迟了，它们几乎同时达到了资源服务器，但保持了顺序，那么资源服务器是不是就检查不出问题了？这时对于资源的访问是不是就发生冲突了？

* 分布式锁+fencing的方案是绝对正确的吗？能证明吗？

### 分布式锁没意义了吗

antirez之前会对fencing机制产生质疑：既然资源服务器本身都能提供互斥的原子操作了，为什么还需要一个分布式锁呢？因此，antirez认为这种fencing机制是很累赘的，他之所以还是提出了这种“Check and Set”操作，只是为了证明在提供fencing token这一点上，Redlock也能做到。

递增的fencing token机制能保证最终操作共享资源的顺序，那些延迟时间太长的操作就无法操作共享资源了。但是基于random token的“Check and Set”操作不会保证这个顺序，那些延迟时间太长的操作如果后到达了，它仍然有可能操作共享资源（当然是以互斥的方式）。

antirez说，锁的ID的大小顺序跟那些操作真正想执行的顺序，是没有什么关系的。关键是能排出一个顺序来，能互斥访问就行了。那么，至于锁的ID是递增的，还是一个random token，自然就不那么重要了。

Flavio Junqueira指出，fencing token机制本质上是要求客户端在每次访问一个共享资源的时候，在执行任何操作之前，先对资源进行某种形式的“标记”(mark)操作，这个“标记”能保证持有旧的锁的客户端请求（如果延迟到达了）无法操作资源。这种标记操作可以是很多形式，fencing token是其中比较典型的一个。

客户端在标记完成之后执行写入操作的时候，存储服务的节点需要判断epoch number是不是最新，然后确定能不能执行写入操作。这里的epoch判断和接下来的写入操作，是不是在一个原子操作里呢？根据Flavio Junqueira的相关描述，我们相信，应该是原子的。

既然资源本身可以提供原子互斥操作了，那么分布式锁还有存在的意义吗？应该说有。客户端可以**利用分布式锁有效地避免冲突，等待写入机会，这对于包含多个节点的分布式资源尤其有用（当然，是出于效率的原因）**。

antirez提出的random token的方式显然不符合Flavio Junqueira对于“标记”操作的定义，因为它无法区分新的token和旧的token。只有递增的数字才能确保最终收敛到最新的操作结果上。

### Chubby的分布式锁是怎样做fencing的？

- 调用Chubby提供的API，CheckSequencer()，将整个sequencer传进去进行检查。这个检查是为了保证客户端持有的锁在进行资源访问的时候仍然有效。
- 将客户端传来的sequencer与资源服务器当前观察到的最新的sequencer进行对比检查。可以理解为与Martin描述的对于fencing token的检查类似。

如果由于兼容的原因，资源服务本身不容易修改，那么Chubby还提供了一种机制：
- lock-delay。Chubby允许客户端为持有的锁指定一个lock-delay的时间值（默认是1分钟）。当Chubby发现客户端被动失去联系的时候，并不会立即释放锁，而是会在lock-delay指定的时间内阻止其它客户端获得这个锁。这是为了在把锁分配给新的客户端之前，让之前持有锁的客户端有充分的时间把请求队列排空(draining the queue)，尽量防止出现延迟到达的未处理请求。

## 参考资料

- [How to do distributed locking](https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html)
- [Is Redlock safe?](http://antirez.com/news/101)
- [herd effect](http://zookeeper.apache.org/doc/r3.4.9/recipes.html#sc_recipes_Locks)
- [Note on fencing and distributed locks](https://fpj.me/2016/02/10/note-on-fencing-and-distributed-locks/)
- [chubby_paper](https://research.google.com/archive/chubby.html)
- [chubby_video](https://www.youtube.com/watch?v=PqItueBaiRg&feature=youtu.be&t=487)
- [clock skew exists](http://jvns.ca/blog/2016/02/09/til-clock-skew-exists/)
- [Martin的这个总结](https://storify.com/martinkl/redlock-discussion)
