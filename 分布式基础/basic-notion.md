## 基础概念

### 垂直扩展和水平扩展

（1）垂直扩展

定义：通过增加单台计算机的资源（如CPU、内存、存储或网卡）来增加系统的性能

优点：无需改变应用程序的架构就能提升性能

缺点：硬件性能的有上限；高性能机器的成本高；可用性低

（2）水平扩展

定义：、将软件运行在多个用网络连接的机器上，在逻辑上视为单体

优点：
    * 高性能：并行处理可以缩短执行时间；负载均衡将工作均匀地分配给各个节点，提高整个系统的性能
    * 可扩展性：通过增加服务器数量来处理更多的请求和存储更多的数据
    * 高可用性：如果一个服务器发生故障，其他服务器可以接管其工作，保证系统的持续运行
    * 成本效益：相较于购买高性能服务器，购买和维护多台中低端服务器可能成本更低

缺点：
    * 复杂性：需要管理和协调多台服务器的工作，这可能会带来额外的复杂性。例如，数据的一致性和同步问题
    * 软件支持：一些旧的或者非分布式的系统可能需要进行大量的修改才能在分布式环境中运行
    * 网络通信：增加服务器数量会增加网络通信的复杂性，可能会导致网络瓶颈，降低系统性能

注意：水平扩展的优点说明了我们为什么要使用分布式系统

### 分布式系统的三个挑战

分布式系统中常见的网络、进程和时钟问题通常是构建和理解分布式系统的基础挑战：

*   网络问题：包括乱序、延迟、丢失、重复和网络分区等
*   进程问题：节点故障或节点卡顿，例如可能由于 GC，卡顿很长一段时间
*   时钟问题：由于时钟漂移，导致多节点时间不同步，无法判断事件发生的先后顺序

### 每个程序员都应该知道的数字

最初的数据来源于 [Teach Yourself Programming in Ten Years](http://norvig.com/21-days.html)

最新数据来自于 [Latency Numbers Every Programmer Should Know](https://colin-scott.github.io/personal_website/research/interactive_latency.html)

对比两份数据，内存、机械硬盘、SSD 的读取速度都有数量级的提升，而其他变化不大。

这些数字指导我们设计性能更佳的程序

*   CPU 的执行指令速度远快于内存 IO，为了弥补两者的速度差距，加了 L1, L2 等缓存。可以把频繁访问的数据放到一起（空间局部性）以充分利用 CPU 的缓存

*   频繁执行的分支应该放在前面，避免分支预测错误

*   内存 IO 远快于磁盘 IO 和网络 IO，所以应该将频繁读取的数据放到内存中

*   SSD 的读写速度远快于机械硬盘。服务器的磁盘应尽量使用 SSD 以获取更好的性能

*   顺序写远快于随机写，所以很多开源软件只做追加写操作，例如 kafka 顺序写消息，MySQL 写 WAL 日志

### 单播、广播和组播

单播：点对点通信
广播：发送给所有设备
组播：发送给特定的设备组

### 分布式编程和并发编程的区别

远程通信的成本要大得多，并且通信链路和进程是不可靠的

### 并发与并行

并发：两个任务并发执行，两者都在进行中，但同一时刻只有一个任务在执行
并行：两个任务并行执行，同一时刻两者都在执行

### 分布式系统的常见误区

（1）处理不是瞬时完成的

*   网络延迟
*   消息可能先进入远程服务器的等待队列，等更早的消息处理完才能被处理

（2）时钟和时间

由于时间漂移，多机时间并不同步，无法用时间戳直接比较不同机器事件发生的先后顺序

即使是在单台机器上，时间也不一定是单调的，即永远不会后退。例如 ntp 同步会使时间后退，当然，恰当的配置能避免此类情况

这不意味着我们完全不能依赖时间，毕竟，任何同步系统都依靠本地时钟实现超时

> Spanner 使用特殊的时间 API 来确定事务的顺序

（3）状态一致性

分布式算法并不保证节点状态严格一致

（4）本地和远程执行

最明显的问题是**延迟**：远程调用的成本比本地调用高很多，因为它涉及序列化/反序列化、双向网络传输等步骤

（5）处理故障的需要

在长时间运行的系统中，节点可能会出现各种故障，例如因内存耗尽、运行时bug而崩溃，网络故障等

（6）网络分区和部分故障

网络分区：

*   两个参与者无法互相通信
*   几组参与者彼此隔开，无法交换消息并继续运行算法

网络分区的麻烦：各个独立的分组可以继续执行并产生冲突的结果

部分故障：如何让系统在部分节点不可用或运行不正常的情况下仍能继续工作

故障很难检测

（7）级联故障

我们无法做到完全隔离故障：被高负载压垮的进程会增加集群其余机器的负载，从而使其它节点更有可能发生故障

熔断策略：断路器模式，避免使用出故障的服务，给它一些时间恢复，并妥善处理失败的调用

合理的重试（退避策略）：

*   客户端不要立刻重试，而是等待一段时间。
*   重试间隔要适当增大
*   重试要有次数限制
*   避免多个客户端集中在同一个时间重试

### 链路模型

**Fair Loss**链路有以下特性：

*   链路可能丢失任何发送的消息，这就是“loss”部分的含义。但重要的是，链路不会自己生成新消息。换句话说，它不会传递一个从未发送过的消息。

*   丢失的消息是以“公平”的方式丢失的，这就是“fair”部分的含义。在这种模型中，“公平”的含义是指链路不会永久性地针对特定的消息进行丢失。例如，如果某个发送方连续发送同一条消息，那么这条消息最终一定会被成功传递，而不会无限期地被丢失。这种特性很重要，因为它保证了即使链路丢失了一些消息，但只要发送方持续重试，任何消息最终都会成功传递（有限重复）。

**消息确认**

确认机制：接收方通知发送方消息已到达。这暗示我们需要给每个消息一个唯一的编号以区分不同的消息。

> 为了提升性能，采用滑动窗口发送消息

**消息重传**

增加确认机制仍然不能保证通信完全可靠：接收方未收到消息；接收方收到消息，但在回复确认前宕机；确认丢失。

为了解决上述问题，需要增加重传机制：进程 A 发送消息后，如果超时仍未收到确认，将尝试再次发送相同的消息。

**消息重复**

重试可能导致消息重复，消息被处理了多次：

*   如果我们要执行的操作是幂等的，那么重复处理消息是安全的，例如覆盖写操作、字典设置值
*   如果不是幂等的，可以使用去重来避免多次处理消息，例如扣钱

**消息传递语义**

*   严格一次传递（exactly-once）：发送方传递一个消息，接收方就能收到一个消息
*   至少一次传递（at-least-once）：发送方将持续重试直到收到确认，否则就认为对方没有收到消息
*   最多一次传递（at-most-once）：发送方仅发送消息而不期待得到任何确认

**消息顺序**

消息有一个递增的、唯一的序列号，接收方可以对消息重新排序，按顺序消费消息

**Perfect Link** 链路特性：

*   **完全可靠**：所有发送的消息最终都会被接收，除非发送者和接受者发生故障。实际中，通过确认和重传保证消息不丢失
*   **无重复**：所有发送的消息最终都只会被接收一次。实际中，消息不丢失就一定会重复，通常是通过只处理一次消息来达到同样的效果
*   **顺序传输**：消息的接收顺序和发送顺序相同。实际中，每个消息有一个链路唯一的序列号，接收端通过这个对消息进行重排序
*   **无无源消息**：只能传递发送者发送的消息，不能生成消息。实际中，存在中间人攻击，例如堡垒机监控

**参考**

*   学习 TCP 协议，主要是确认重传机制、流控机制、拥塞控制？
*   TCP 仅在单个链接上保证可靠传递。是否可以保证跨多个链接保证顺序？
*   端到端的一致性

## 网络模型

**同步网络**：
*   所有节点的时钟漂移有上限
*   网络的传输时间有上限
*   所有节点的计算速度一样

这意味着整个网络按照 round 运行，每个 round 中任何节点都要执行完本地计算并且可以完成一个任意大小消息的传输。一个发出的消息如果在一个 round 内没有到达，那么一定是网络中断造成的，这个消息会丢失，不会延迟到第二个 round 到达。在现实生活中这种网络比较少

**异步网络**：
*   节点的时钟漂移无上限
*   网络的传输时间无上限
*   所有节点的计算速度无法预料

这就是我们打交道的网络类型。在异步网络中，有些故障非常难解决，比如当你发给一个节点一个消息之后几秒钟都没有收到他的应答，有可能这个节点计算非常慢，但是也可能是节点 crash 或者网络延迟造成的，你很难判断到底是发生了什么样的故障

同步网络和异步网络的最大区别在于**故障的可检测性**。具体来说，在同步网络中，可通过超时检测到网络故障或节点故障；而在异步网络中，这些故障是无法被检测到的，存在误判的情况。那超时故障检测机制是不是没用了呢？不是，可通过多次检测来减少误判的概率。

注意，分布式系统中，无法区分网络故障和节点故障，一定程度上是等价的，例如消息丢失和节点宕机等价

## 故障模型

|故障划分|	解释|
|--------|------|
|Byzantine failure|	节点可以任意篡改发送给其他节点的数据|
|Authentication detectable byzantine failure (ADB)|	Byzantine failure的特例；节点可以篡改数据，但不能伪造其他节点的数据|
|Response failure|	ADB的特例，节点可以返回错误数据，但只能返回受限的错误数据|
|Performance failure|	又名timing failure, 节点未在特定时间段内收到数据，即时间太早或太晚|
|Omission failure|	Performance failure 的特例；节点收到数据的时间无限晚，即收不到数据|
|Crash failure|	Omission failure 的特例；在 omission failure 的基础上，增加了节点停止响应的假设，也即持续性地omission failure|
|Fail-stop failure|	Crash failure 的特例；在 Crash failure 的基础上增加了错误可检测的假设|

故障模型即针对节点故障也针对网络故障，因为分布式系统无法区分节点故障和网络故障

网络模型和故障模型的关系：大多数是**正交**的，在故障模型上叠加网络模型并不会分化出新模型。但有一些特殊的情况：

*   网络分区故障是 Omission failure 的一个特例，因为分布式系统无法区分节点故障和网络故障
*   同步网络和异步网络最大的区别是故障的可检测性，所以 Fail-stop failure 是在 Crash failure 基础上增加了同步网络的假设

## FLP 定理

在最小化异步网络通信场景下，即使只有一个节点出现故障，也没有一种完全正确的共识算法使得非故障节点达成共识

最小化异步网络指：消息系统是异步的，但是任何消息都会被接受有且仅有一次，并且无法伪造或者丢失。这是比一般的异步网络更加可靠的一个网络模型。

共识：所有节点对某个值达成一致。这个值可能是数据库的某个版本，或者区块链的某个特定块。

完全正确：指同时满足 safety 和 liveness
*   safety：保证坏的事情绝对不会发生，例如 Paxos 算法不会同时对两个值达成一致，也不会达成一致后又对另一个值达成一致
*   liveness：保证好的事情终会发生，即算法在有限的时间内可以结束，反面是死循环

FLP 不可能原理则是在说，**要保证 safety 的话就一定不满足 liveness**。在实际应用中, Paxos, Raft 都是保证 safety 但放松了 liveness 的要求（例如 Paxos 的活锁问题），所以他们都不是完全正确的算法, 理论上存在进入无限循环的可能性。实际上概率非常低, 在工程中完全可以使用

## 一致性模型

### 线性一致性

### 最终一致性

## 全序广播（Total Order Broadcast）

全序广播用于确保消息在所有进程以相同的顺序被传递，它有两个主要的特性：

*   安全性：如果消息 m 被传递到了某个节点，那么它将被传递到所有节点
*   顺序性：消息在所有节点以相同的顺序被传递。任意两个消息 m 和 n，如果某个节点先接收到 m 后接收到 n，那么所有节点都是先接收到 m 后接收到 n

传递消息类似于在一个日志的末尾追加写入

全序广播并不等价于线性一致性，因为线性一致性要求读取一定能看到最近的写入，而全序广播没有保证消息何时被送达

如何保证读取是线性一致的？

*   等待直到目标序号之前的消息都已传递
*   把读取操作也当做一条消息广播出去，当它出现在日志上时，在它之前的写入就是最新值
*   仅从含有最新日志的数据库读取

## 原子提交（Atomic Commit）

原子提交：所有参与者要么都提交操作，要么都不提交

## 参考文章

*   [分布式系统中的网络模型和故障模型](https://danielw.cn/network-failure-models)
*   [FLP Impossibility的证明](https://danielw.cn/FLP-proof)
