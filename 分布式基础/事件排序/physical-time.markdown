# 物理时间

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [物理时间](#物理时间)
  - [闰秒](#闰秒)
    - [出现原因](#出现原因)
    - [解决办法](#解决办法)
      - [阶跃式](#阶跃式)
      - [渐进式](#渐进式)
  - [NTP](#ntp)
    - [背景](#背景)
    - [原理](#原理)
    - [缺点](#缺点)
  - [事件排序](#事件排序)
  - [参考文献](#参考文献)

<!-- /code_chunk_output -->

## 闰秒

### 出现原因

如何定义一秒有多长？

**世界时**（UT1）：基于地球自转运动来计量时间，定义地球自转一周为一天，绕太阳公转一周为一年。由于地球自转速率正在变慢，所以地球自转一圈需要的时间会变长，定义的一秒相对以前也会变长。世界时跟我们的生活息息相关，例如我们习惯了太阳的最高点就是中午 12 点。

**原子时**（TAI）：基于铯原子的振荡周期频率来计量时间。精确度非常高，但它与我们的生活没有关联。

**协调世界时**（UTC）：为了统一原子时与世界时直接的差距，产生了 UTC。它的秒长采用原子时秒长，时刻与世界时之差保持在正负 0.9 秒之内，必要时用阶跃 1 整秒的方式来调整。这个 1 秒的调整，就称为闰秒。

Linux 系统记录的是自公元 1970 年 1 月 1 日 0 时 0 分 0 秒以来的秒数和毫秒数，一分钟 60 秒，一天 86400 秒是系统定义死的。也就是说，这个定义没有包含闰秒，需要额外的逻辑来处理闰秒。

闰秒是一个发生频率不高且不规律的事件，在过去 30 年里已经发生过 20 多次。闰秒的信息在由 IERS 决定并公布过后，会存储在 NIST 的一个专门列表里面，ntpd 在启动之后会访问 NIST 的时间服务器获取这个 leap-seconds.list 文件，然后它就知道什么时候有怎样的闰秒了。

### 解决办法

#### 阶跃式

* 如果 UTC 比世界时快 1 秒，需要插入一个正闰秒，等世界时追上来。假设当前 UTC 时间是 23:59:59，那么下一秒是 23:59:60，再下一秒才是 24:00:00。
* 如果 UTC 比世界时慢 1 秒，需要插入一个负闰秒，追上世界时。假设当前 UTC 时间是 23:59:58，那么下一秒是 24:00:00，23:59:59 被跳过了。

优点：实现简单

缺点：有些操作系统或应用系统无法处理插入正闰秒的情况（即 23:59:60），可能出 bug 或者宕机。

#### 渐进式

Google：在闰秒时刻前 24 小时开始调慢时间；在闰秒时刻，与标准 UTC 的误差接近 1 秒；闰秒时刻后，与标准 UTC 一致。

Aliyun or Amazon：在闰秒时刻前 12 小时开始调慢时间；在闰秒时刻，比标准 UTC 慢 0.5 秒；闰秒时刻后，比标准 UTC 快 0.5 秒，12 小时后与标准 UTC 一致，然后恢复正常秒长。

优点：应用对闰秒无感知，不需要特殊处理这种情况。

缺点：实现复杂。

## NTP

### 背景

计算机是如何计时的？由于石英钟的振荡频率比较稳定，所以计算机内部采用石英钟计时。简单来说，石英钟每振荡一定的次数，计算机就把时间往前推进一秒。但是石英钟不够精确，容易被机器温度影响，存在过快或过慢的问题。所以，**单靠计算机自己是无法保证时钟的精确的**，必须不断地校准时间，目前普遍采用的一种方式是计算机与 NTP 时间服务器定期进行网络同步。

### 原理

![ntp](https://raw.githubusercontent.com/YanQiu0207/image/main/ntp.PNG)

我们根据上图来推导 A 和 B 之间的时间偏移：

A 和 B 之间的网络往返时间 RTT（Round Trip Time）为：

$$\tag{1}
\delta = (T4 - T1) - (T3-T2)
$$

假设 A --> B 和 B -->A 的网络传输时间是相等的，那么 B --> A 的网络传输时间是 RTT 的一半，即

$$\tag{4}
\alpha = \frac \delta 2
$$

当 A 是时间为 $T4$，B 对应的时间为

$$\tag{5}
T4^{\prime} = T3 + \alpha = T3 + ((T4 - T1) - (T3-T2))/2 = (T4 + T3 + T2 - T1) / 2
$$

由此可以算出 A 与 B 之间的偏移为

$$\tag{6}
\theta = T4 - T4^{\prime} = ((T1 + T4) - (T2 + T3)) / 2
$$

因为我们假设了A --> B 和 B -->A 的网络传输时间是相等的，所以时间的准确性受网络环境的影响大，

* 公网，误差通常在几十毫秒以内，网络不好时，达到 100 毫秒甚至更多
* 局域网，可以达到 1 毫秒的精度

具体的实现会更复杂一点。NTP 客户端会定期轮询三个或更多服务器，将计算得到的往返时延和时间偏移进行统计分析，剔除异常值，并从最好的三个候选结果中算出时间偏移，然后调整时钟频率以减少时间偏移，以达到纠正时间的目的。

### 缺点

* 误差没有上限。
* 同步时间后可能导致时间回退，对业务造成影响，例如一些依赖时间的唯一 ID 生成算法；统计某段代码的执行时间等。当然，ntp 可以通过一些手段设置时间不回退。

> 核心思想：分摊法

## 事件排序

我们经常要对分布式系统中的不同事件的次序进行判定，例如一致性模型，就是给予不同读写操作一个合理的排序；例如为了防止并发事务相互干扰，也需要判定各个事务操作的排序。如果这些排序只涉及单个进程的事件，那还是比较容易的；但一旦要对多个进程的事件进行排序，就没那么容易了。

在分布式系统中，如何确定任意两个事件发生的先后顺序？最先想到的办法：通过比较事件发生时的时间（wall time）来确定先后顺序。举个例子，绝对时间是 50 ms，A 节点提交了一个事务 T1，执行 x = 10，时间戳是 60 ms。10 ms后，B 节点提交了另一个事务 T2，执行 x = 20，时间戳是 55 ms。如果有人进行一个快照读，例如读取 55 ms 时的数据，那么他有可能读到的是事务 T2 写入的值。这个不符合常理，因为绝对时间 55 ms 时 T2 还未执行。

本质问题是：在分布式系统中，每个节点的时钟（石英钟）受环境因素的影响（例如温度、湿度等），会产生时间漂移，导致多机物理时间不同步。这使得直接比较各个节点的本地时间戳没有意义。

使用 NTP 时间同步能解决我们的问题吗？不能，因为 NTP 只能缩短节点间的时间差异，无法保证严格一致。

## 参考文献

* [计算机的时钟（一）：NTP 协议](http://yang.observer/2020/07/11/time-ntp/)
* [你真的理解计算机时间吗？](https://blog.csdn.net/c183662101/article/details/106362982)
* [ntp导致的时钟回拨](https://chowdera.com/2021/05/20210531094647763p.html)